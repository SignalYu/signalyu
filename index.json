[{"content":"Bean 生命周期状态图 graph TB subgraph state[ ] s1[1. 声明 Bean Definitions] --\u003e s2[2. 加载 Bean Definitions] --\u003e s3[3. 处理 Bean Definitions] --\u003e s4[4. Bean 实例化] --\u003e s5[5. Bean 属性赋值] --\u003e s6[6. Bean 后置处理（初始化前）] --\u003e s7[7. Bean 初始化] --\u003e s8[8. Bean 后置处理（初始化后）] --\u003e s9[9. Bean 存储在 IoC 容器中] --\u003e s10[10. 销毁 Bean] end n1[\"`使用 XML，带包扫描的注解，带有 @Configuration 注解的类声明 Bean`\"] -.- s1 n2[\"`**BeanDefinitionReader**：解析配置并创建 BeanDefinition对象`\"] -.- s2 n3[\"`**BeanFactoryPostProcessor**：在实际创建 Bean 之前修改 BeanDefinitions`\"] -.- s3 n4[\"`**BeanFactory**：调用 Bean 的构造函数。需要时会将实例化行为委托给自定义 FactoryBean 实例。`\"] -.- s4 n5[\"`如果依赖以构造器形式注入，则被依赖的 Bean 先创建`\"] -.- s5 n6[\"`**BeanPostProcessor**：在 Bean 初始化之前修改 Bean`\"] -.- s6 n7[\"`Bean 在触发 **init** 方法后完成初始化`\"] -.- s7 n8[\"`*BeanPostProcessor**：在 Bean 初始化之后修改 Bean，通常存在循环依赖或者对 Bean 封装代理对象时调用`\"] -.- s8 n9[\"`Bean 初始化全面完成，存储在 IoC 容器中`\"] -.- s9 n10[\"`在销毁 IoC 容器或 Bean 时，会调用 Bean 的 destroy 方法`\"] -.- s10 点击查看代码 Person.java PersonBeanPostProcessor.java Main.java beans.xml 输出结果 package org.signalyu; import org.springframework.beans.BeansException; import org.springframework.beans.factory.*; public class Person implements BeanClassLoaderAware, BeanFactoryAware, InitializingBean, DisposableBean { private String name; public Person() { System.out.println(\"1. 实例化 Bean...\"); } public void setName(String name) { this.name = name; System.out.println(\"2. Bean 属性赋值: \" + name); } @Override public void setBeanClassLoader(ClassLoader classLoader) { System.out.println(\"3. 设置 Bean 的类加载器：\" + classLoader); } @Override public void setBeanFactory(BeanFactory beanFactory) throws BeansException { System.out.println(\"4. 设置 Bean 工厂: \" + beanFactory); } @Override public void afterPropertiesSet() { System.out.println(\"6. 检验 Bean 属性是否成功赋值: \" + name); } public void initBean() { System.out.println(\"7. 初始化 Bean...\"); } @Override public void destroy() { System.out.println(\"10. 销毁 Bean:...\"); } } package org.signalyu; import org.springframework.beans.BeansException; import org.springframework.beans.factory.config.BeanPostProcessor; public class PersonBeanPostProcessor implements BeanPostProcessor { @Override public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException { System.out.println(\"5. Bean 初始化前: \" + beanName); return bean; } @Override public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException { System.out.println(\"8. Bean 初始化后: \" + beanName); return bean; } } package org.signalyu; import org.springframework.context.ApplicationContext; import org.springframework.context.support.ClassPathXmlApplicationContext; public class Main { public static void main(String[] args) { ApplicationContext applicationContext = new ClassPathXmlApplicationContext(\"beans.xml\"); Person personBean = applicationContext.getBean(\"personBean\", Person.class); System.out.println(\"9. 使用 Bean: \" + personBean); // 只有正常关闭 spring 容器才会执行销毁方法 ClassPathXmlApplicationContext context = (ClassPathXmlApplicationContext) applicationContext; context.close(); } } \u0026lt;?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u0026lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"\u003e \u0026lt;!-- init-method 属性指定初始化方法。 destroy-method 属性指定销毁方法。 --\u003e \u0026lt;bean id=\"personBean\" class=\"org.signalyu.Person\" init-method=\"initBean\" destroy-method=\"destroy\"\u003e \u0026lt;/bean\u003e \u0026lt;!--配置Bean后处理器。这个后处理器将作用于当前配置文件中所有的bean。--\u003e \u0026lt;bean class=\"org.signalyu.PersonBeanPostProcessor\"/\u003e \u0026lt;/beans\u003e 1. 实例化 Bean... 2. Bean 属性赋值: Signal Yu 3. 设置 Bean 的类加载器：jdk.internal.loader.ClassLoaders$AppClassLoader@251a69d7 4. 设置 Bean 工厂: org.springframework.beans.factory.support.DefaultListableBeanFactory@dc7df28: defining beans [personBean,org.signalyu.PersonBeanPostProcessor#0]; root of factory hierarchy 5. Bean 初始化前: personBean 6. 检验 Bean 属性是否成功赋值: Signal Yu 7. 初始化 Bean... 8. Bean 初始化后: personBean 9. 使用 Bean: org.signalyu.Person@16aa8654 10. 销毁 Bean:... ","permalink":"https://signalyu.github.io/posts/tech/spring/3-bean-life-cycle/","summary":"Bean 生命周期状态图 graph TB subgraph state[ ] s1[1. 声明 Bean Definitions] --\u003e s2[2. 加载 Bean Definitions] --\u003e s3[3. 处理 Bean Definitions] --\u003e s4[4. Bean 实例化] --\u003e s5[5. Bean 属性赋值] --\u003e s6[6. Bean 后置处理（初始化前）] --\u003e s7[7. Bean 初始化] --\u003e s8[8. Bean 后置处理（初始化后）] --\u003e s9[9. Bean 存储在 IoC 容器中] --\u003e s10[10. 销毁 Bean] end n1[\"`使用 XML，带包扫描的注解，带有 @Configuration 注解的类声明 Bean`\"] -.- s1 n2[\"`**BeanDefinitionReader**：解析配置并创建 BeanDefinition对象`\"] -.- s2 n3[\"`**BeanFactoryPostProcessor**：在实际创建 Bean 之前修改 BeanDefinitions`\"] -.- s3 n4[\"`**BeanFactory**：调用 Bean 的构造函数。需要时会将实例化行为委托给自定义 FactoryBean 实例。`\"","title":"Spring：Bean 生命周期"},{"content":"Spring MVC 执行流程图 Spring MVC 执行流程图 graph TB subgraph dispatchServlet[前端控制器（DispatchServlet）] direction TB doDispatch ~~~ getHandler ~~~ getHandlerAdapter ~~~ processDispatchResult end subgraph handlerMapping[处理器映射器] end subgraph handlerAdapter[处理器适配器] handle end subgraph handler[处理器（Handler）] 执行业务逻辑 end subgraph viewResolver[视图解析器] resolveViewName end subgraph view[视图（View）] render end user(((用户))) --\u003e|① 请求| dispatchServlet dispatchServlet --\u003e|② 匹配 Handler| handlerMapping handlerMapping --\u003e|③ 返回 HandlerExecutionChain| dispatchServlet dispatchServlet --\u003e|④ 获取 HandlerAdapter| handlerAdapter handlerAdapter --\u003e|⑤ 返回 HandlerAdapter| dispatchServlet dispatchServlet -.- preHandler[⑥ 执行 preHandler] -.-\u003e|⑦ 执行 handle| handlerAdapter handlerAdapter --\u003e|⑧ 执行 handleInternal| handler --\u003e|⑨ 返回 ModelAndView| handlerAdapter handlerAdapter -.-|⑩ 返回 ModelAndView| postHandler[⑪ 执行 postHandler] -.-\u003e dispatchServlet dispatchServlet --\u003e|⑫ 解析视图| viewResolver --\u003e|⑬ 返回 view|dispatchServlet dispatchServlet --\u003e|⑭ 调用 render| view --\u003e|⑮ 渲染视图| dispatchServlet dispatchServlet -.- afterCompletion[⑯ 执行 afterCompletion] --\u003e|⑰ 响应| user DispatcherServlet（前端控制器） 点击查看 DispatcherServlet.class 核心代码 DispatcherServlet.class public class DispatcherServlet extends FrameworkServlet { protected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception {} protected HandlerExecutionChain getHandler(HttpServletRequest request) throws Exception {} private void processDispatchResult(HttpServletRequest request, HttpServletResponse response, @Nullable HandlerExecutionChain mappedHandler, @Nullable ModelAndView mv, @Nullable Exception exception) throws Exception {} protected void render(ModelAndView mv, HttpServletRequest request, HttpServletResponse response) throws Exception {} protected View resolveViewName(String viewName, @Nullable Map model, Locale locale, HttpServletRequest request) throws Exception {} } doDispatch 点击查看 doDispatch 方法核心代码 java protected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception { /* * 根据请求获取处理器（处理器执行链对象） * 该处理器属于请求级别，一次请求对应一个对象 * 该对象描述了本次请求执行的具体处理器、应该执行的拦截器及其执行顺序 */ HandlerExecutionChain mappedHandler = this.getHandler(processedRequest); /* * 根据处理器获取处理器适配器 * Web 服务器在启动时创建多个 HandlerAdapter 并使用 List 集合保存 * 此时还没有进行数据绑定，即表单提交的数据在此时还没有转换为 pojo 对象 */ HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler()); // 执行请求对应的所有拦截器中的 preHandle 方法 if (!mappedHandler.applyPreHandle(processedRequest, response)) { return; } /* * 通过处理器适配器调用 handle 方法，并返回 ModelAndView 对象 * 在调用 handle 之前会进行数据绑定，将表单提交的数据绑定到处理器方法上 * 在数据绑定的过程中会使用到 HttpMessageConverter 消息转换器 */ mv = ha.handle(processedRequest, response, mappedHandler.getHandler()); // 执行请求对应的所有拦截器中的 postHandle 方法 mappedHandler.applyPostHandle(processedRequest, response, mv); // 处理分发结果 this.processDispatchResult(processedRequest, response, mappedHandler, mv, (Exception)dispatchException); } HandlerExecutionChain（处理器执行链对象） HandlerExecutionChain mappedHandler = this.getHandler(processedRequest); 点击查看 HandlerExecutionChain 核心代码 HandlerExecutionChain.class public class HandlerExecutionChain { private final Object handler; private final List interceptorList; private int interceptorIndex; public HandlerExecutionChain(Object handler, List interceptorList) { this.interceptorList = new ArrayList(); this.interceptorIndex = -1; // 检查传入的 handler 是否是 HandlerExecutionChain 的实例 if (handler instanceof HandlerExecutionChain originalChain) { // 如果是，则从原始链中获取处理器并复制其拦截器列表 this.handler = originalChain.getHandler(); this.interceptorList.addAll(originalChain.interceptorList); } else { // 如果不是，则直接使用传入的 handler this.handler = handler; } // 将传入的拦截器列表添加到现有的拦截器列表中 this.interceptorList.addAll(interceptorList); } } Object handler 底层对应的是一个 HandlerMethod 对象，该对象在 Web 服务器启动初始化 Spring IoC 容器时创建，它的两个主要参数为 beanName 和 Method。 HandlerMethod 对象 this.getHandler 代码分析 HandlerExecutionChain mappedHandler = this.getHandler(processedRequest); 点击查看 this.getHandler 方法代码 getHandler @Nullable protected HandlerExecutionChain getHandler(HttpServletRequest request) throws Exception { if (this.handlerMappings != null) { Iterator var2 = this.handlerMappings.iterator(); /* * 遍历获取符合请求的 HandlerMapping 对象，以此获取正确的 HandlerExecutionChain * 如果处理方法中使用的是 @RequestMapping 注解，则对应的 mapping 为 RequestMappingHandlerMapping */ while(var2.hasNext()) { HandlerMapping mapping = (HandlerMapping)var2.next(); HandlerExecutionChain handler = mapping.getHandler(request); if (handler != null) { return handler; } } } return null; } mapping.getHandler 代码分析 HandlerExecutionChain handler = mapping.getHandler(request); mapping 的变量类型为接口 HandlerMapping（处理器映射器），该接口有很多实现类，常用的是 RequestMappingHandlerMapping，它是 RequestMapping 注解专用的处理器映射器。 所有 HandlerMapping 都是在 Web 服务器启动时创建并存放在 List 集合中。 处理器映射器创建过程 创建 HandlerMapping 时，底层会执行 new HandlerMethod()，具体过程如下图： --- title: 处理器映射器创建过程与 mapping.getHandler --- graph subgraph handlerMapping[HandlerMapping 接口] HM_getHandler[getHandler] end subgraph abstractHandlerMapping[AbstractHandlerMapping 抽象类] AHM_getHandler[getHandler] end subgraph abstractHandlerMethodMapping[AbstractHandlerMethodMapping 抽象类] AHMM_registerHandlerMethod[registerHandlerMethod] --\u003e|② 调用| AHMM_register[register] --\u003e|③ 调用| AHMM_createHandlerMethod[createHandlerMethod] end subgraph requestMappingInfoHandlerMapping[RequestMappingInfoHandlerMapping 抽象类] end subgraph requestMappingHandlerMapping[RequestMappingHandlerMapping 类] RMHM_registerHandlerMethod[registerHandlerMethod] end handlerMapping -.-\u003e|实现| abstractHandlerMapping --\u003e|继承| abstractHandlerMethodMapping --\u003e|继承| requestMappingInfoHandlerMapping --\u003e|继承| requestMappingHandlerMapping RMHM_registerHandlerMethod --\u003e|① 调用| AHMM_registerHandlerMethod AHMM_createHandlerMethod --\u003e|④调用| handlerMethodConstructor[\"new HandlerMethod(...)\"] mapping.getHandler --\u003e|调用| AHM_getHandler 点击查看上图涉及的代码 getHandler registerHandlerMethod register createHandlerMethod // AbstractHandlerMapping 抽象类中的 getHandler 方法 public final HandlerExecutionChain getHandler(HttpServletRequest request) throws Exception { Object handler = this.getHandlerInternal(request); // ... if (handler instanceof String) { String handlerName = (String)handler; handler = this.obtainApplicationContext().getBean(handlerName); } HandlerExecutionChain executionChain = this.getHandlerExecutionChain(handler, request); // ... return executionChain; } protected HandlerMethod createHandlerMethod(Object handler, Method method) { if (handler instanceof String beanName) { return new HandlerMethod(beanName, this.obtainApplicationContext().getAutowireCapableBeanFactory(), this.obtainApplicationContext(), method); } else { return new HandlerMethod(handler, method); } } public void register(T mapping, Object handler, Method method) { // ... HandlerMethod handlerMethod = AbstractHandlerMethodMapping.this.createHandlerMethod(handler, method); // ... } protected HandlerMethod createHandlerMethod(Object handler, Method method) { if (handler instanceof String beanName) { return new HandlerMethod(beanName, this.obtainApplicationContext().getAutowireCapableBeanFactory(), this.obtainApplicationContext(), method); } else { return new HandlerMethod(handler, method); } } getHandlerAdapter HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler()); 程序员写的每一个 Controller 都有与之对应的处理器适配器，常用的处理器适配器是 RequestMappingHandlerAdapter。 HandlerAdapter 是一个接口。在 Web 服务器启动阶段，所有该接口的实现类都会被创建并存放在 List 集合中。 点击查看 getHandlerAdapter 代码 getHandlerAdapter protected HandlerAdapter getHandlerAdapter(Object handler) throws ServletException { if (this.handlerAdapters != null) { Iterator var2 = this.handlerAdapters.iterator(); while(var2.hasNext()) { HandlerAdapter adapter = (HandlerAdapter)var2.next(); if (adapter.supports(handler)) { // 返回支持处理器的适配器 return adapter; } } } // 未找到支持处理器的适配器，抛出 Servlet 异常 throw new ServletException(\"No adapter for handler [\" + handler + \"]: The DispatcherServlet configuration needs to include a HandlerAdapter that supports this handler\"); } applyPreHandle if (!mappedHandler.applyPreHandle(processedRequest, response)) { return; } 点击查看 applyPreHandle 代码 applyPreHandle boolean applyPreHandle(HttpServletRequest request, HttpServletResponse response) throws Exception { // 顺序调用 interceptorList 中的 HandlerInterceptor 对象的 preHandle 方法 for(int i = 0; i \u003c this.interceptorList.size(); this.interceptorIndex = i++) { HandlerInterceptor interceptor = (HandlerInterceptor)this.interceptorList.get(i); if (!interceptor.preHandle(request, response, this.handler)) { this.triggerAfterCompletion(request, response, (Exception)null); return false; } } return true; } ha.handle mv = ha.handle(processedRequest, response, mappedHandler.getHandler()); 在处理器适配器（HandlerAdapter）中执行的任务主要包括：\n将前端提交的 form 数据通过 HttpMessageConverter 转换为 POJO 对象 将数据绑定到 HandlerMethod 对象上 调用 HandlerMethod 并返回 ModelView 点击查看 ha.handle 相关代码 handle 方法 handleInternal 方法 invokeHandlerMethod 方法 @Nullable public final ModelAndView handle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { return this.handleInternal(request, response, (HandlerMethod)handler); } // RequestMappingHandlerAdapter.class protected ModelAndView handleInternal(HttpServletRequest request, HttpServletResponse response, HandlerMethod handlerMethod) throws Exception { // ... ModelAndView mav = this.invokeHandlerMethod(request, response, handlerMethod); // ... return mav; } // RequestMappingHandlerAdapter.class @Nullable protected ModelAndView invokeHandlerMethod(HttpServletRequest request, HttpServletResponse response, HandlerMethod handlerMethod) throws Exception { // 获取一个数据绑定工厂 WebDataBinderFactory binderFactory = this.getDataBinderFactory(handlerMethod); // 获取一个可调用的处理器方法 ServletInvocableHandlerMethod invocableMethod = this.createInvocableHandlerMethod(handlerMethod); // 给可调用的方法绑定数据 invocableMethod.setDataBinderFactory(binderFactory); // 给可调用的方法设置参数 invocableMethod.setParameterNameDiscoverer(this.parameterNameDiscoverer); // 执行可调用方法 invocableMethod.invokeAndHandle(webRequest, mavContainer, new Object[0]); } applyPostHandle mappedHandler.applyPostHandle(processedRequest, response, mv); 点击查看 applyPostHandle 相关代码 applyPostHandle 方法 void applyPostHandle(HttpServletRequest request, HttpServletResponse response, @Nullable ModelAndView mv) throws Exception { // 逆序（--i）取出拦截器对象并执行每个对象的 postHandle 方法 for(int i = this.interceptorList.size() - 1; i \u003e= 0; --i) { HandlerInterceptor interceptor = (HandlerInterceptor)this.interceptorList.get(i); interceptor.postHandle(request, response, this.handler, mv); } } processDispatchResult this.processDispatchResult(processedRequest, response, mappedHandler, mv, (Exception)dispatchException); 点击查看 processDispatchResult 相关代码 processDispatchResult 方法 render 方法 resolveViewName 方法 triggerAfterCompletion 方法 private void processDispatchResult(HttpServletRequest request, HttpServletResponse response, @Nullable HandlerExecutionChain mappedHandler, @Nullable ModelAndView mv, @Nullable Exception exception) throws Exception { // ... this.render(mv, request, response); // ... if (mappedHandler != null) { mappedHandler.triggerAfterCompletion(request, response, (Exception)null); } } protected void render(ModelAndView mv, HttpServletRequest request, HttpServletResponse response) throws Exception { // ... // 通过视图解析器进行解析，返回视图对象 this.resolveViewName(viewName, mv.getModelInternal(), locale, request); // ... // 调用视图的渲染方法，完成响应 view.render(mv.getModelInternal(), request, response); } @Nullable protected View resolveViewName(String viewName, @Nullable Map model, Locale locale, HttpServletRequest request) throws Exception { if (this.viewResolvers != null) { Iterator var5 = this.viewResolvers.iterator(); while(var5.hasNext()) { // 视图解析器 ViewResolver viewResolver = (ViewResolver)var5.next(); // 通过视图解析器返回视图对象 View view = viewResolver.resolveViewName(viewName, locale); if (view != null) { return view; } } } return null; } // HandlerExecutionChain.class void triggerAfterCompletion(HttpServletRequest request, HttpServletResponse response, @Nullable Exception ex) { // // 逆序调用拦截器对象的 afterCompletion 方法 for(int i = this.interceptorIndex; i \u003e= 0; --i) { HandlerInterceptor interceptor = (HandlerInterceptor)this.interceptorList.get(i); try { interceptor.afterCompletion(request, response, this.handler, ex); } catch (Throwable var7) { logger.error(\"HandlerInterceptor.afterCompletion threw exception\", var7); } } } 面试题 简述 Spring MVC 的工作流程 用户发送请求至前端控制器（DispatcherServlet） DispatcherServlet 收到请求调用处理器映射器（HandlerMapping） 处理器映射器返回处理器执行链（HandlerExecutionChain） 前端控制器调用处理器适配器（HandlerAdapter） 处理器适配器找到具体的处理器（Controller） 处理器执行完业务逻辑后返回 ModelAndView 处理器适配器将 Controller 的执行结果返回给前端控制器 前端控制器将 ModelAndView 传给视图解析器（ViewResolver） 视图解析器解析后返回具体的 View 前端控制器根据 View 进行视图渲染 前端控制器响应用户 ","permalink":"https://signalyu.github.io/posts/tech/spring-mvc/1-spring-mvc-execution-flow/","summary":"Spring MVC 执行流程图 Spring MVC 执行流程图 graph TB subgraph dispatchServlet[前端控制器（DispatchServlet）] direction TB doDispatch ~~~ getHandler ~~~ getHandlerAdapter ~~~ processDispatchResult end subgraph handlerMapping[处理器映射器] end subgraph handlerAdapter[处理器适配器] handle end subgraph handler[处理器（Handler）] 执行业务逻辑 end subgraph viewResolver[视图解析器] resolveViewName end subgraph view[视图（View）] render end user(((用户))) --\u003e|① 请求| dispatchServlet dispatchServlet --\u003e|② 匹配 Handler| handlerMapping handlerMapping --\u003e|③ 返回 HandlerExecutionChain| dispatchServlet dispatchServlet --\u003e|④ 获取 HandlerAdapter| handlerAdapter handlerAdapter --\u003e|⑤ 返回 HandlerAdapter| dispatchServlet dispatchServlet -.- preHandler[⑥ 执行 preHandler] -.-\u003e|⑦ 执行 handle| handlerAdapter handlerAdapter --\u003e|⑧ 执行 handleInternal| handler --\u003e|⑨ 返回 ModelAndView| handlerAdapter handlerAdapter -.","title":"Spring MVC 执行流程"},{"content":"AOP 相关概念 AOP 相关概念 横切关注点（Crosscutting Concern）：横切关注点是指业务处理过程中的附加功能。一类业务可以有多个横切关注点（附加功能），例如上述例子中的的借书方法具有日志和安全校验两个附加功能，即具有两个横切关注点。 切面（Aspect）：在不同类业务中提取的同类核心关注点构成的模块称为切面。例如上述例子中的借书和还书方法可提取出日志切面（LoggingAspect）和校验切面（AuthenticationAspect）。 连接点（Joint Point）：连接点是指业务处理过程中能够应用切面功能的位置。 通知（Advice）：通知是指切面在某个特定连接点上触发的行为。 切入点（Pointcut）：切入点是指业务处理过程中实际应用切面功能的连接点位置。例如核心业务处理前，核心业务成功处理后，核心业务处理发生异常时等等。 织入（Weaving）：织入是指将附加功能集成到目标对象的过程。 AOP 代码 点击查看代码 BookService BookServiceImpl LoggingAspect AuthenticationAspect BookServiceTest beans.xml 输出结果 package org.signalyu; public interface BookService { boolean borrowBook(String bookId); boolean returnBook(String bookId); } package org.signalyu; import org.springframework.stereotype.Service; import java.util.HashMap; import java.util.Map; @Service public class BookServiceImpl implements BookService { final private Map\u0026ltString, Boolean\u003e bookStatus = new HashMap\u0026lt;\u003e(); public BookServiceImpl() { // Initialize book status map with some books available initially bookStatus.put(\"1234567890\", true); bookStatus.put(\"0987654321\", true); bookStatus.put(\"9876543210\", true); } @Override public boolean borrowBook(String bookId) { if (bookStatus.containsKey(bookId)) { if (bookStatus.get(bookId)) { System.out.println(\"Borrowing book: \" + bookId); // Set the book status to false indicating it's borrowed bookStatus.put(bookId, false); return true; } else { System.out.println(\"Book: \" + bookId + \" is already borrowed.\"); return false; } } else { throw new RuntimeException(\"Error: The book with ID \" + bookId + \" is not available in the library.\"); } } @Override public boolean returnBook(String bookId) { if (bookStatus.containsKey(bookId)) { if (!bookStatus.get(bookId)) { System.out.println(\"Returning book: \" + bookId); // Set the book status to true indicating it's returned and available again bookStatus.put(bookId, true); return true; } else { System.out.println(\"Error: The book with ID \" + bookId + \" is not borrowed.\"); return false; } } else { throw new RuntimeException(\"Error: The book with ID \" + bookId + \" is not available in the library.\"); } } } package org.signalyu; import org.aspectj.lang.JoinPoint; import org.aspectj.lang.ProceedingJoinPoint; import org.aspectj.lang.annotation.*; import org.springframework.core.annotation.Order; import org.springframework.stereotype.Component; @Aspect @Component @Order(1) public class LoggingAspect { // Pointcut for methods in BookService class @Pointcut(\"execution(* org.signalyu.BookService.*(..))\") public void bookServiceMethods() { } // Advice for logging before method execution @Before(\"bookServiceMethods()\") public void beforeMethodExecution(JoinPoint joinPoint) { System.out.println(\"Logging before \" + joinPoint.getSignature().getName() + \" execution\"); } // Advice for logging after method execution @After(\"bookServiceMethods()\") public void afterMethodExecution(JoinPoint joinPoint) { System.out.println(\"Logging after \" + joinPoint.getSignature().getName() + \" execution\"); } // Advice for logging after method returns a value @AfterReturning(pointcut = \"bookServiceMethods()\", returning = \"result\") public void afterReturningMethod(JoinPoint joinPoint, Object result) { System.out.println(\"Logging after \" + joinPoint.getSignature().getName() + \" returns: \" + result); } // Advice for logging after method throws an exception @AfterThrowing(pointcut = \"bookServiceMethods()\", throwing = \"exception\") public void afterThrowingMethod(JoinPoint joinPoint, Exception exception) { System.out.println(\"Logging after \" + joinPoint.getSignature().getName() + \" throws exception: \" + exception.getMessage()); } // Advice for logging around method execution @Around(\"bookServiceMethods()\") public Object aroundMethodExecution(ProceedingJoinPoint joinPoint) throws Throwable { System.out.println(\"Logging around \"+ joinPoint.getSignature().getName() +\" execution - Before\"); Object result; try { result = joinPoint.proceed(); System.out.println(\"Logging around \"+ joinPoint.getSignature().getName() +\" execution - After\"); } catch (Exception e) { System.out.println(\"Logging around \"+ joinPoint.getSignature().getName() +\" execution - Exception\"); throw e; } return result; } } package org.signalyu; import org.aspectj.lang.JoinPoint; import org.aspectj.lang.annotation.Aspect; import org.aspectj.lang.annotation.Before; import org.aspectj.lang.annotation.Pointcut; import org.springframework.core.annotation.Order; import org.springframework.stereotype.Component; @Aspect @Component @Order(2) public class AuthenticationAspect { // Pointcut for methods in BookService class that require authentication @Pointcut(\"execution(* org.signalyu.BookService.borrowBook(..)) || execution(* org.signalyu.BookService.returnBook(..))\") public void authenticatedMethods() { } // Advice for authenticating before method execution @Before(value = \"authenticatedMethods()\") public void authenticate(JoinPoint joinPoint) { System.out.println(\"Authentication before \" + joinPoint.getSignature().getName() + \" execution\"); } } import org.junit.jupiter.api.Test; import org.signalyu.BookService; import org.springframework.context.ApplicationContext; import org.springframework.context.support.ClassPathXmlApplicationContext; public class BookServiceTest { @Test public void testBookService() { ApplicationContext context = new ClassPathXmlApplicationContext(\"beans.xml\"); BookService bookService = context.getBean(BookService.class); String bookId = \"1234567890\"; System.out.println(\"==============Borrowing Book================\"); bookService.borrowBook(bookId); System.out.println(\"=======Borrowing the same book again =======\"); bookService.borrowBook(bookId); System.out.println(\"==============Returning Book================\"); bookService.returnBook(bookId); System.out.println(\"=================== END ====================\"); // bookService.borrowBook(\"999\"); // Wrong book id } } \u0026lt;?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u0026lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd\"\u003e \u0026lt;!-- 进行包扫描--\u003e \u0026lt;context:component-scan base-package=\"org.signalyu\" /\u003e \u0026lt;!-- 开启aspectj框架注解支持--\u003e \u0026lt;aop:aspectj-autoproxy /\u003e \u0026lt;/beans\u003e ==============Borrowing Book================ Logging around borrowBook execution - Before Logging before borrowBook execution Authentication before borrowBook execution Borrowing book: 1234567890 Logging after borrowBook returns: true Logging after borrowBook execution Logging around borrowBook execution - After =======Borrowing the same book again ======= Logging around borrowBook execution - Before Logging before borrowBook execution Authentication before borrowBook execution Book: 1234567890 is already borrowed. Logging after borrowBook returns: false Logging after borrowBook execution Logging around borrowBook execution - After ==============Returning Book================ Logging around returnBook execution - Before Logging before returnBook execution Authentication before returnBook execution Returning book: 1234567890 Logging after returnBook returns: true Logging after returnBook execution Logging around returnBook execution - After =================== END ==================== ","permalink":"https://signalyu.github.io/posts/tech/spring/2-spring-aop/","summary":"AOP 相关概念 AOP 相关概念 横切关注点（Crosscutting Concern）：横切关注点是指业务处理过程中的附加功能。一类业务可以有多个横切关注点（附加功能），例如上述例子中的的借书方法具有日志和安全校验两个附加功能，即具有两个横切关注点。 切面（Aspect）：在不同类业务中提取的同类核心关注点构成的模块称为切面。例如上述例子中的借书和还书方法可提取出日志切面（LoggingAspect）和校验切面（AuthenticationAspect）。 连接点（Joint Point）：连接点是指业务处理过程中能够应用切面功能的位置。 通知（Advice）：通知是指切面在某个特定连接点上触发的行为。 切入点（Pointcut）：切入点是指业务处理过程中实际应用切面功能的连接点位置。例如核心业务处理前，核心业务成功处理后，核心业务处理发生异常时等等。 织入（Weaving）：织入是指将附加功能集成到目标对象的过程。 AOP 代码 点击查看代码 BookService BookServiceImpl LoggingAspect AuthenticationAspect BookServiceTest beans.xml 输出结果 package org.signalyu; public interface BookService { boolean borrowBook(String bookId); boolean returnBook(String bookId); } package org.signalyu; import org.springframework.stereotype.Service; import java.util.HashMap; import java.util.Map; @Service public class BookServiceImpl implements BookService { final private Map\u0026ltString, Boolean\u003e bookStatus = new HashMap\u0026lt;\u003e(); public BookServiceImpl() { // Initialize book status map with some books available initially bookStatus.","title":"Spring：理解 AOP"},{"content":"控制反转 控制反转（IoC）：控制反转是一种设计原则，指的是对象的创建和管理权从应用程序的某个对象反转给 IoC 容器。如下图所示，汽车类（Car）依赖于引擎类（Engine），即 Car 类对其依赖—— Engine 类对象的创建具有控制权。在传统模式下，Car 类必须在其内部创建 Engine 类。而在 IoC 模式下，Engine 类对象的创建和管理由外部实体——IoC 容器完成，也就是说，对 Engine 类对象的创建和管理权限由 Car 类转移到 IoC 容器中。由于在 IoC 模式下 Car 类不需要在其内部创建 Engine 类对象，因此实现了代码解耦。\ngraph LR direction LR subgraph traditional[传统模式] direction LR car[Car] -.- depend((依赖)) -.-\u003e engine[Engine] car --\u003e|创建| engine end graph subgraph iocPattern[IoC 模式] car[Car] -.- depend((依赖)) -.-\u003e engine[Engine] config[XML/注解配置] ==\u003e ioc[IoC 容器] --\u003e|依赖注入| depend ioc --\u003e|创建| car \u0026 engine end 传统模式代码 Car.java Engine.java package org.signalyu; public class Car { private Engine engine; public Car() { // Car 类在其内部创建 Engine 类 this.engine = new Engine(); } public void start() { engine.start(); } } package org.signalyu; public class Engine { public void start() { System.out.println(\"org.signalyu.Engine started\"); } } IoC 模式代码 Car.java Engine.java Main.java beans.xml package org.signalyu; public class Car { private Engine engine; public Car(Engine engine) { this.engine = engine; } public void start() { engine.start(); } } package org.signalyu; public class Engine { public Engine() { } public void start() { System.out.println(\"org.signalyu.Engine started\"); } } package org.signalyu; import org.springframework.context.ApplicationContext; import org.springframework.context.support.ClassPathXmlApplicationContext; public class Main { public static void main(String[] args) { ApplicationContext context = new ClassPathXmlApplicationContext(\"beans.xml\"); Car car = context.getBean(\"car\",Car.class); car.start(); } } \u0026lt;?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u0026lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"\u003e \u0026lt;!-- Define the Engine bean --\u003e \u0026lt;bean id=\"engine\" class=\"org.signalyu.Engine\"/\u003e \u0026lt;!-- Define the Car bean with constructor injection --\u003e \u0026lt;bean id=\"car\" class=\"org.signalyu.Car\"\u003e \u0026lt;constructor-arg name=\"engine\" ref=\"engine\"/\u003e \u0026lt;/bean\u003e \u0026lt;/beans\u003e 依赖注入 依赖注入：- 依赖指的是对象和对象之间的关联关系，注入指的是一种数据传递行为，通过注入行为来让对象和对象产生关系。综合来看，依赖注入是指 IoC 容器动态地向某个对象提供它所依赖的外部资源。在上述例子中，IoC 容器会在运行时动态地创建 Engine 类并将其注入到 Car 类对象中。\n","permalink":"https://signalyu.github.io/posts/tech/spring/1-spring-ioc-di/","summary":"控制反转 控制反转（IoC）：控制反转是一种设计原则，指的是对象的创建和管理权从应用程序的某个对象反转给 IoC 容器。如下图所示，汽车类（Car）依赖于引擎类（Engine），即 Car 类对其依赖—— Engine 类对象的创建具有控制权。在传统模式下，Car 类必须在其内部创建 Engine 类。而在 IoC 模式下，Engine 类对象的创建和管理由外部实体——IoC 容器完成，也就是说，对 Engine 类对象的创建和管理权限由 Car 类转移到 IoC 容器中。由于在 IoC 模式下 Car 类不需要在其内部创建 Engine 类对象，因此实现了代码解耦。\ngraph LR direction LR subgraph traditional[传统模式] direction LR car[Car] -.- depend((依赖)) -.-\u003e engine[Engine] car --\u003e|创建| engine end graph subgraph iocPattern[IoC 模式] car[Car] -.- depend((依赖)) -.-\u003e engine[Engine] config[XML/注解配置] ==\u003e ioc[IoC 容器] --\u003e|依赖注入| depend ioc --\u003e|创建| car \u0026 engine end 传统模式代码 Car.java Engine.java package org.signalyu; public class Car { private Engine engine; public Car() { // Car 类在其内部创建 Engine 类 this.","title":"Spring：理解控制反转和依赖注入"},{"content":"Maven 简介 --- title: Maven 软件的工作原理图 --- flowchart subgraph mavenRepo[Maven 依赖仓库] officialRepo[官方仓库]--\u003e|定期备份|mirrorRepo[镜像仓库] mirrorRepo[镜像仓库]--\u003e|下载|localRepo[本地仓库] end subgraph dependencyManage[依赖管理] dispatch[依赖传递]~~~conflict[依赖冲突]~~~inheritence[依赖继承]~~~cohesion[依赖聚合] end subgraph settings[配置 settings.xml] localRepository~~~mirror~~~jdk end subgraph lifeCircle[生命周期] clean ~~~ compile ~~~ test ~~~ package ~~~ install ~~~ others[...] end subgraph projects[项目] javaSE[JavaSE]~~~javaWeb[JavaWeb] pom.xml -.- javaSE \u0026 javaWeb end subgraph app[包] jar ~~~ war end localRepo --\u003e|引用| maven((Maven)) --- dependencyManage maven -.- settings javaSE \u0026 javaWeb --\u003e install install --\u003e localRepo package --\u003e app IntelliJ --\u003e|新建| javaSE --\u003e|war| javaWeb 依赖管理：Maven 可以管理项目的依赖，包括自动下载所需依赖库、自动下载依赖需要的依赖并且保证版本没有冲突、依赖版本管理等。 构建管理：项目构建是指将源代码、配置文件、资源文件等转化为能够运行或部署的应用程序或库的过程。Maven 可以管理项目的编译、测试、打包、部署等构建过程。通过实现标准的构建生命周期，Maven 可以确保每一个构建过程都遵循同样的的规则和最佳实践。同时，Maven 的插件机制也使得开发者可以对构建过程进行扩展和定制。 Maven 目录结构 . ├── bin ├── boot ├── conf │ └── logging └── lib ├── ext │ ├── hazelcast │ └── redisson └── jansi-native └── Windows ├── x86 └── x86_64 bin 目录含有 Maven 的运行脚本 boot 目录含有 plexus-classworlds 类加载器框架 conf 目录含有 Maven 的核心配置文件（settings.xml） lib 目录含有 Maven 运行时所需要的 Java 类库 Maven 功能配置 通过修改 conf 目录下的 settings.xml 来修改 Maven 的一些默认配置。通常需要修改一下三项配置：\n依赖本地缓存位置（本地仓库位置） Maven 下载镜像 Maven 选用编译项目的 JDK 版本 修改本地仓库缓存位置 修改本地仓库缓存位置 localRepository \u0026lt;!-- localRepository | The path to the local repository maven will use to store artifacts. | | Default: ${user.home}/.m2/repository \u0026lt;localRepository\u003e/path/to/local/repo\u0026lt;/localRepository\u003e --\u003e \u0026lt;localRepository\u003e/Users/signal/maven-repository\u0026lt;/localRepository\u003e 为什么要修改本地仓库缓存位置？ 当 jar 包下载失败时，需要找到本地仓库缓存位置下的 jar 包删除后才能正常继续下载。 配置国内阿里云镜像 配置国内镜像可以提升 jar 包下载速度。\n配置国内镜像 mirror \u0026lt;mirrors\u003e ... \u0026lt;mirror\u003e \u0026lt;id\u003ealimaven\u0026lt;/id\u003e \u0026lt;name\u003ealiyun maven\u0026lt;/name\u003e \u0026lt;url\u003ehttp://maven.aliyun.com/nexus/content/groups/public/\u0026lt;/url\u003e \u0026lt;mirrorOf\u003ecentral\u0026lt;/mirrorOf\u003e \u0026lt;/mirror\u003e ... \u0026lt;/mirrors\u003e 配置完毕后将默认 mirror 注释掉。\n配置 JDK 17 配置 JDK 17 配置 JDK 17 \u0026lt;profiles\u003e ... \u0026lt;profile\u003e \u0026lt;id\u003ejdk-17\u0026lt;/id\u003e \u0026lt;activation\u003e \u0026lt;activeByDefault\u003etrue\u0026lt;/activeByDefault\u003e \u0026lt;jdk\u003e17\u0026lt;/jdk\u003e \u0026lt;/activation\u003e \u0026lt;properties\u003e \u0026lt;maven.compiler.source\u003e17\u0026lt;/maven.compiler.source\u003e \u0026lt;maven.compiler.target\u003e17\u0026lt;/maven.compiler.target\u003e \u0026lt;maven.compiler.compilerVersion\u003e17\u0026lt;/maven.compiler.compilerVersion\u003e \u0026lt;/properties\u003e \u0026lt;/profile\u003e ... \u0026lt;/profiles\u003e Maven 工程 Maven 工程的 GAVP Maven 中的 GAVP 是指 GroupId、ArtifactId、Version、Packaging 等四个属性的缩写，其中前三个为必选项，Packaging 为可选项。\nGroupID 格式：com.{公司/BU}.业务线.[子业务线]，最多四级。例如：com.alibaba.sourcing.multilang ArtifactId 格式：产品线-模块名。例如：tc-client Version 版本号格式推荐：主版本号.次版本号.修订号 主版本号：做了不兼容的 API 修改或者增加了能改变产品方向的新功能。 次版本号：做了向下兼容的功能性新增，例如新增类、接口等。 修订号：修复 bug，保持 API 兼容性等。 Packaging 定义规则：指定项目打包类型。 jar：默认值，代表普通的 Java 工程，打包以后是 .jar 结尾的文件 war：代表 Java 的 web 工程，打包以后是 .war 结尾的文件 pom：表示不打包，用作继承中的父工程（父工程只负责依赖管理和聚合，不参与打包）。 创建 Maven Java SE 工程 ⌘ + , 打开设置面板 -\u0026gt; Build, Execution, Deployment + -\u0026gt; Build Tools -\u0026gt; Maven -\u0026gt; Maven Home Path 处选择本地 Maven -\u0026gt; User Settings 处选择本地 Maven 的 conf 目录下的 settings.xml IDEA 中 Maven 项目设置 File -\u0026gt; new Module IDEA 中创建 Maven Module 创建 Maven Java Web 工程（方式一） 先创建 Maven Java SE 工程，并在 pom.xml 文件中添加 \u0026lt;packaging\u0026gt;war\u0026lt;packaging/\u0026gt; \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;project xmlns=\u0026#34;http://maven.apache.org/POM/4.0.0\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\u0026#34;\u0026gt; \u0026lt;modelVersion\u0026gt;4.0.0\u0026lt;/modelVersion\u0026gt; \u0026lt;parent\u0026gt; \u0026lt;groupId\u0026gt;org.signalyu\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;maven_java\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.0-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;/parent\u0026gt; \u0026lt;artifactId\u0026gt;maven_web\u0026lt;/artifactId\u0026gt; \u0026lt;packaging\u0026gt;war\u0026lt;/packaging\u0026gt; \u0026lt;properties\u0026gt; \u0026lt;maven.compiler.source\u0026gt;17\u0026lt;/maven.compiler.source\u0026gt; \u0026lt;maven.compiler.target\u0026gt;17\u0026lt;/maven.compiler.target\u0026gt; \u0026lt;project.build.sourceEncoding\u0026gt;UTF-8\u0026lt;/project.build.sourceEncoding\u0026gt; \u0026lt;/properties\u0026gt; \u0026lt;/project\u0026gt; 设置 web 资源路径和 web.xml 路径：File -\u0026gt; Project Structure -\u0026gt; 操作如下步骤： 设置 web 资源路径和 web.xml 路径 webapp 有小蓝点表示创建成功（没有小蓝点可点击 Maven 面板中的刷新按钮）。 创建 Maven Java Web 工程（方式二） ⌘ + , 打开设置面板 -\u0026gt; Plugins -\u0026gt; 搜索 JBLJavaToWeb 并安装 创建 Maven Java SE 工程 选中新添加的 Java SE 工程，右击选中 JBLJavaToWeb 即可完成创建。 Maven 工程项目结构 |-- pom.xml # Maven 项目管理文件 |-- src |-- main # 项目主要代码 | |-- java # Java 源代码目录 | | `-- com/example/myapp # 开发者代码主目录 | | |-- controller # 存放 Controller 层代码的目录 | | |-- service # 存放 Service 层代码的目录 | | |-- dao # 存放 DAO 层代码的目录 | | `-- model # 存放数据模型的目录 | |-- resources # 资源目录，存放配置文件、静态资源等 | | |-- log4j.properties # 日志配置文件 | | |-- spring-mybatis.xml # Spring Mybatis 配置文件 | | `-- static # 存放静态资源的目录 | | |-- css # 存放 CSS 文件的目录 | | |-- js # 存放 JavaScript 文件的目录 | | `-- images # 存放图片资源的目录 | `-- webapp # 存放 WEB 相关配置和资源 | |-- WEB-INF # 存放 WEB 应用配置文件 | | |-- web.xml # Web 应用的部署描述文件 | | `-- classes # 存放编译后的 class 文件 | `-- index.html # Web 应用入口页面 `-- test # 项目测试代码 |-- java # 单元测试目录 `-- resources # 测试资源目录 pom.xml：Maven 项目管理文件，用于描述目的依赖和构建配置等信息。 src/main/java：存放项目的 Java 源代码。 src/main/resource：存放项目的资源文件，如配置文件、静态资源等。 src/main/webapp/WEB-INF：存放 Web 应用的配置文件。 src/main/webapp/index.jsp：Web 应用的入口页面。 src/test/java：存放项目的测试代码。 src/test/resources：存放测试相关的资源文件，如测试配置文件等。 基于 IDEA 进行 Maven 工程构建 命令 描述 mvn compile 编译项目，生成 target 文件 mvn package 打包项目，生成 jar 或 war 文件 mvn clean 清理编译或打包后的项目结构 mvn install 打包后上传到 maven 本地仓库 mvn deploy 只打包，上传到 maven 私服仓库 mvn site 生成站点 mvn test 执行测试源码 当构建 Maven Web 工程时，如果 war 包打包插件与 JDK 版本不匹配，则在 pom.xml 文件下添加如下代码即可： \u0026lt;build\u0026gt; \u0026lt;!-- jdk17 和 war包版本插件不匹配 --\u0026gt; \u0026lt;plugins\u0026gt; \u0026lt;plugin\u0026gt; \u0026lt;groupId\u0026gt;org.apache.maven.plugins\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;maven-war-plugin\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.2.2\u0026lt;/version\u0026gt; \u0026lt;/plugin\u0026gt; \u0026lt;/plugins\u0026gt; \u0026lt;/build\u0026gt; 打包（package）与安装（install）的区别：打包是指将工程打成 jar 或者 war 文件，保存在 target 目录下；安装是指将当前工程所生成的 jar 或者 war 文件，安装到本地仓库，会按照坐标保存到指定位置。 基于 IDEA 进行 Maven 依赖管理 Maven 的依赖管理能够帮助开发人员自动解决软件包依赖问题，使得开发人员能够轻松地将其他开发人员开发的模块或第三方框架集成到自己的应用程序或模块中，避免出现版本冲突和依赖缺失等问题。\n通过定义 POM 文件，Maven 能够自动解析项目的依赖关系，并通过 Maven 仓库自动下载和管理依赖，从而避免了手动下载和管理依赖的繁琐工作和可能引发的版本冲突问题。\n依赖管理 \u0026lt;!-- 通过编写依赖 jar 包的 gav 必要属性，引入第三方依赖！ scope 属性是可选的，可以指定依赖生效范围！ 依赖信息查询方式： 1. maven仓库信息官网 https://mvnrepository.com/ 2. mavensearch插件搜索 --\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;!-- 引入具体的依赖包 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;log4j\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;log4j\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.2.17\u0026lt;/version\u0026gt; \u0026lt;!-- 依赖范围 --\u0026gt; \u0026lt;scope\u0026gt;runtime\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; 依赖版本统一提取和维护 \u0026lt;properties\u0026gt; \u0026lt;!--声明版本--\u0026gt; \u0026lt;junit.version\u0026gt;4.12\u0026lt;/junit.version\u0026gt; \u0026lt;!-- 也可以通过 maven规定的固定的key，配置maven的参数！如下配置编码格式！--\u0026gt; \u0026lt;project.build.sourceEncoding\u0026gt;UTF-8\u0026lt;/project.build.sourceEncoding\u0026gt; \u0026lt;project.reporting.outputEncoding\u0026gt;UTF-8\u0026lt;/project.reporting.outputEncoding\u0026gt; \u0026lt;/properties\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;junit\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;junit\u0026lt;/artifactId\u0026gt; \u0026lt;!--引用 properties 声明版本 --\u0026gt; \u0026lt;version\u0026gt;${junit.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; 依赖范围 通过设置坐标的依赖范围（scope），可以设置对应 jar 包的作用范围：编译环境、测试环境、运行环境\n依赖范围 描述 compile 编译依赖范围，scope 元素的缺省值，在编译、测试、运行过程均会被引入。 test 测试依赖范围，只对测试 classpath 有效。 provided 已提供依赖范围，只对编译和测试有效。 runtime 运行时依赖范围，只对测试和运行有效。 system 系统依赖范围，其效果与 provided 的依赖范围一致。其用于添加非 Maven 仓库的本地依赖，通过依赖元素 dependency 中的 systemPath 元素指定本地依赖的路径。鉴于使用其会导致项目的可移植性降低，一般不推荐使用。 import 导入依赖范围，该依赖范围只能与 dependencyManagement 元素配合使用，其功能是将目标 pom.xml 文件中 dependencyManagement 的配置导入合并到当前 pom.xml 的 dependencyManagement 中。 Maven 工程依赖下载失败错误解决 在使用 Maven 构建项目时，可能会发生依赖下载错误的情况，主要原因有以下几种：\n下载依赖时出现网络故障或仓库服务器宕机等原因，导致无法连接至 Maven 仓库，从而无法下载依赖。 依赖项的版本号或配置文件中的版本号错误，或者依赖项没有正确定义，导致 Maven 下载的依赖项与实际需要的不一致，从而引发错误。 本地 Maven 仓库或缓存被污染或损坏，导致 Maven 无法正确地使用现有的依赖项。 解决方案如下：\n检查网络的连接和 Maven 仓库服务器状态。 确保依赖项的版本号与项目对应的版本号匹配，并检查 POM 文件中的依赖项是否正确。 清楚本地 Maven 仓库缓存 （lastUpdated 文件）。因为当本地仓库缓存中存在 lastUpdated 缓存文件时，刷新 Maven 面板也不会重新下载。 Maven 工程 Build 构建配置 构建配置在 pom.xml 文件中的 build 标签中指定。\n指定打包命名 \u0026lt;!-- 默认的打包名称：artifactid+verson.打包方式 --\u0026gt; \u0026lt;build\u0026gt; \u0026lt;finalName\u0026gt;定义打包名称\u0026lt;/finalName\u0026gt; \u0026lt;/build\u0026gt; 指定打包文件 默认情况下，按照 maven 工程结构放置的文件会默认被编译和打包。当需要指定打包文件时，可以使用 resources 标签来指定要打包资源的文件夹要把哪些静态资源打包到 classes 根目录下。例如，mybatis 中有时需要将用于编写 SQL 语句的映射文件和 mapper 接口都写在 src/main/java 下的某个包中，此时映射文件默认不打包，解决方法如下：\n\u0026lt;build\u0026gt; \u0026lt;!--设置要打包的资源位置--\u0026gt; \u0026lt;resources\u0026gt; \u0026lt;resource\u0026gt; \u0026lt;!--设置资源所在目录--\u0026gt; \u0026lt;directory\u0026gt;src/main/java\u0026lt;/directory\u0026gt; \u0026lt;includes\u0026gt; \u0026lt;!--设置包含的资源类型--\u0026gt; \u0026lt;include\u0026gt;**/*.xml\u0026lt;/include\u0026gt; \u0026lt;/includes\u0026gt; \u0026lt;/resource\u0026gt; \u0026lt;/resources\u0026gt; \u0026lt;/build\u0026gt; 配置依赖插件 可以通过 build/plugins/plugin 标签引入插件。常用的插件主要包括：修改 JDK 版本、tomcat 插件、mybatis 分页插件、mybatis 逆向工程插件等等。\n\u0026lt;build\u0026gt; \u0026lt;plugins\u0026gt; \u0026lt;!-- java 编译插件，配置 jdk 的编译版本 --\u0026gt; \u0026lt;plugin\u0026gt; \u0026lt;groupId\u0026gt;org.apache.maven.plugins\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;maven-compiler-plugin\u0026lt;/artifactId\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;source\u0026gt;1.8\u0026lt;/source\u0026gt; \u0026lt;target\u0026gt;1.8\u0026lt;/target\u0026gt; \u0026lt;encoding\u0026gt;UTF-8\u0026lt;/encoding\u0026gt; \u0026lt;/configuration\u0026gt; \u0026lt;/plugin\u0026gt; \u0026lt;!-- tomcat 插件 --\u0026gt; \u0026lt;plugin\u0026gt; \u0026lt;groupId\u0026gt;org.apache.tomcat.maven\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;tomcat7-maven-plugin\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.2\u0026lt;/version\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;port\u0026gt;8090\u0026lt;/port\u0026gt; \u0026lt;path\u0026gt;/\u0026lt;/path\u0026gt; \u0026lt;uriEncoding\u0026gt;UTF-8\u0026lt;/uriEncoding\u0026gt; \u0026lt;server\u0026gt;tomcat7\u0026lt;/server\u0026gt; \u0026lt;/configuration\u0026gt; \u0026lt;/plugin\u0026gt; \u0026lt;/plugins\u0026gt; \u0026lt;/build\u0026gt; 依赖传递 依赖传递性：假设存在 Maven 项目 A、B、C，且项目 B 依赖项目 A，项目 C 依赖项目 B，则项目 C 依赖 项目 A。 在 C 依赖 B，B 依赖 A 的前提下，A 能否传递到 C，取决于 B 依赖 A 时使用的依赖范围以及配置 B 依赖 A 时使用 compile 范围，可以传递 B 依赖 A 时使用 test 和 provided 范围，不能传递，此时需要专门配置。 B 依赖 A 时，若配置了\u0026lt;optional\u0026gt;true\u0026lt;/optional\u0026gt;标签，则不能传递。 依赖冲突 当项目中出现重复的 jar 包时，将产生依赖冲突。 Maven 可以根据“短路优先”和“先声明优先”原则自动解决依赖冲突。 短路优先原则： A -\u0026gt; B -\u0026gt; C -\u0026gt; D -\u0026gt; X(version 0.0.1) A -\u0026gt; F -\u0026gt; X(version 0.0.2) 则 A 依赖与 X(version 0.0.2) 先声明优先原则： A—\u0026gt;E—\u0026gt;X(version 0.0.1) A—\u0026gt;F—\u0026gt;X(version 0.0.2) 优先选择先声明的 X 手动解决依赖冲突（不推荐）： \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.atguigu.maven\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;pro01-maven-java\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.0-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;compile\u0026lt;/scope\u0026gt; \u0026lt;!-- 使用excludes标签配置依赖的排除 --\u0026gt; \u0026lt;exclusions\u0026gt; \u0026lt;!-- 在exclude标签中配置一个具体的排除 --\u0026gt; \u0026lt;exclusion\u0026gt; \u0026lt;!-- 指定要排除的依赖的坐标（不需要写version） --\u0026gt; \u0026lt;groupId\u0026gt;commons-logging\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;commons-logging\u0026lt;/artifactId\u0026gt; \u0026lt;/exclusion\u0026gt; \u0026lt;/exclusions\u0026gt; \u0026lt;/dependency\u0026gt; 依赖继承 Maven 中的依赖继承是指在父工程中统一管理项目中的依赖信息，以简化项目的管理和维护工作。\n父工程配置 父工程的打包方式必须是 pom。\n\u0026lt;groupId\u0026gt;org.signalyu.maven\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;maven-parent\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.0-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;packaging\u0026gt;pom\u0026lt;/packaging\u0026gt; 子工程 子工程中使用 parent 标签指定当前工程的父工程。 如果子工程坐标中的 groupId 和 version 与父工程一致，那么可以省略。 \u0026lt;parent\u0026gt; \u0026lt;!-- 父工程的坐标 --\u0026gt; \u0026lt;groupId\u0026gt;org.signalyu.maven\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;maven-parent\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.0-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;/parent\u0026gt; \u0026lt;!-- 子工程的坐标 --\u0026gt; \u0026lt;artifactId\u0026gt;maven-module1\u0026lt;/artifactId\u0026gt; 父工程依赖统一管理 父工程使用 dependencyManagement 标签对依赖进行管理，被管理的依赖并没有真正被引入到工程。\n\u0026lt;dependencyManagement\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-core\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;6.0.10\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-beans\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;6.0.10\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-context\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;6.0.10\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-aop\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;6.0.10\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;/dependencyManagement\u0026gt; 子工程引用父工程中的依赖信息时，若版本号省略，则表示当前依赖版本由父工程的 dependencyManagement 决定。\n\u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-core\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-beans\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-context\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-aop\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; Maven 聚合 Maven 聚合是指将多个项目组织到一个父级项目中，以便一起构建和管理的机制。\n\u0026lt;project\u0026gt; \u0026lt;groupId\u0026gt;org.signalyu\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;parent-project\u0026lt;/artifactId\u0026gt; \u0026lt;packaging\u0026gt;pom\u0026lt;/packaging\u0026gt; \u0026lt;version\u0026gt;1.0.0\u0026lt;/version\u0026gt; \u0026lt;modules\u0026gt; \u0026lt;module\u0026gt;child-project1\u0026lt;/module\u0026gt; \u0026lt;module\u0026gt;child-project2\u0026lt;/module\u0026gt; \u0026lt;/modules\u0026gt; \u0026lt;/project\u0026gt; 当触发父工程构建命令时、将引发所有子模块构建。\n","permalink":"https://signalyu.github.io/posts/tech/maven/1-maven-notes/","summary":"Maven 简介 --- title: Maven 软件的工作原理图 --- flowchart subgraph mavenRepo[Maven 依赖仓库] officialRepo[官方仓库]--\u003e|定期备份|mirrorRepo[镜像仓库] mirrorRepo[镜像仓库]--\u003e|下载|localRepo[本地仓库] end subgraph dependencyManage[依赖管理] dispatch[依赖传递]~~~conflict[依赖冲突]~~~inheritence[依赖继承]~~~cohesion[依赖聚合] end subgraph settings[配置 settings.xml] localRepository~~~mirror~~~jdk end subgraph lifeCircle[生命周期] clean ~~~ compile ~~~ test ~~~ package ~~~ install ~~~ others[...] end subgraph projects[项目] javaSE[JavaSE]~~~javaWeb[JavaWeb] pom.xml -.- javaSE \u0026 javaWeb end subgraph app[包] jar ~~~ war end localRepo --\u003e|引用| maven((Maven)) --- dependencyManage maven -.- settings javaSE \u0026 javaWeb --\u003e install install --\u003e localRepo package --\u003e app IntelliJ --\u003e|新建| javaSE --\u003e|war| javaWeb 依赖管理：Maven 可以管理项目的依赖，包括自动下载所需依赖库、自动下载依赖需要的依赖并且保证版本没有冲突、依赖版本管理等。 构建管理：项目构建是指将源代码、配置文件、资源文件等转化为能够运行或部署的应用程序或库的过程。Maven 可以管理项目的编译、测试、打包、部署等构建过程。通过实现标准的构建生命周期，Maven 可以确保每一个构建过程都遵循同样的的规则和最佳实践。同时，Maven 的插件机制也使得开发者可以对构建过程进行扩展和定制。 Maven 目录结构 .","title":"Maven 笔记"},{"content":"日程管理系统 MVC 模型 flowchart LR subgraph server[\"`**日程管理系统 MVC 模型**`\"] subgraph mysql[\"MySQL 数据库\"] direction TB subgraph tables[ ] subgraph userTable[sys_user 表] direction LR uid ~~~ username ~~~ userpwd end end end subgraph model[Model（模型层）] subgraph pojo[POJO] subgraph sysUserClass[SysUser.java] sysUserCode[\" private Integer uid; private String username; private String userPwd;\"] end end subgraph dao[DAO（持久层）] sysUserDao[SysUserDao 接口]~~~ baseDao[BaseDao 类] sysUserDao -.-\u003e sysUserDaoImpl[SysUserDaoImpl] baseDao --\u003e|继承| sysUserDaoImpl end subgraph service[Service（业务层）] sysUserService[SysUserService 接口] sysUserService -.-\u003e sysUserServiceImpl[SysUserServiceImpl] end end subgraph controller[Controller（与 View 构成表示层）] httpServlet[HttpServlet] ~~~ baseController[BaseController] ~~~ sysUserController[SysUserController] ~~~ utils[工具类] httpServlet -.-\u003e|实现| baseController --\u003e|继承| sysUserController utils -.-\u003e|使用| sysUserController end subgraph view[View（视图层）] html ~~~ css ~~~ js ~~~ others[...] end subgraph client[客户端] end end sysUserClass -.- sysUserDaoImpl userTable ==\u003e baseDao baseDao ==\u003e userTable sysUserClass -.-\u003e|使用| sysUserServiceImpl sysUserClass -.-\u003e|使用| sysUserController sysUserController ==\u003e|操作|sysUserServiceImpl ==\u003e|操作| sysUserDaoImpl client --\u003e|Request| sysUserController sysUserController --\u003e|Response| client controller --\u003e|更新| view --\u003e|展示| client 部分参考代码 flowchart SysUserController ==\u003e|调用| SysUserServiceImpl ==\u003e|调用| SysUserDaoImpl ==\u003e|调用| BaseDao --\u003e|操作| database[(数据库)] 点击查看代码 SysUserController SysUserServiceImpl SysUserDaoImpl BaseDao protected void login(HttpServletRequest req, HttpServletResponse resp) throws IOException { // 1. 接收用户名和密码 String username = req.getParameter(\"username\"); String userPwd = req.getParameter(\"userPwd\"); // 2. 调用服务层方法，根据用户名查询用户信息 SysUser loginUser = userService.findByUsername(username); if (loginUser == null) { resp.sendRedirect(\"/loginUsernameError.html\"); } else if (!MD5Util.encrypt(userPwd).equals(loginUser.getUserPwd())) { // 3. 判断密码是否匹配 resp.sendRedirect(\"/loginUserPwdError.html\"); } else { // 登录成功之后，将登录的信息放入session HttpSession session = req.getSession(); session.setAttribute(\"sysUser\", loginUser); // 4. 跳转到首页 resp.sendRedirect(\"/showSchedule.html\"); } } public class SysUserServiceImpl implements SysUserService { // ... @Override public SysUser findByUsername(String username) { return userDao.findByUsername(username); } } public class SysUserDaoImpl extends BaseDao implements SysUserDao { // ... @Override public SysUser findByUsername(String username) { String sql = \"select uid, username, user_pwd userPwd from sys_user where username = ?\"; List sysUserList = baseQuery(SysUser.class, sql, username); return sysUserList != null \u0026\u0026 sysUserList.size() != 0 ? sysUserList.get(0) : null; } } public class BaseDao { public List baseQuery(Class clazz, String sql, Object ... args){ List list =new ArrayList\u003c\u003e(); Connection connection = JDBCUtil.getConnection(); PreparedStatement preparedStatement=null; ResultSet resultSet =null; int rows = 0; try { // 准备语句对象 preparedStatement = connection.prepareStatement(sql); // 设置语句上的参数 for (int i = 0; i \u003c args.length; i++) { preparedStatement.setObject(i+1,args[i]); } // 执行 查询 resultSet = preparedStatement.executeQuery(); ResultSetMetaData metaData = resultSet.getMetaData(); int columnCount = metaData.getColumnCount(); // 将结果集通过反射封装成实体类对象 while (resultSet.next()) { // 使用反射实例化对象 Object obj =clazz.getDeclaredConstructor().newInstance(); for (int i = 1; i \u003c= columnCount; i++) { String columnName = metaData.getColumnLabel(i); Object value = resultSet.getObject(columnName); // 处理datetime类型字段和java.util.Data转换问题 if(value.getClass().equals(LocalDateTime.class)){ value= Timestamp.valueOf((LocalDateTime) value); } Field field = clazz.getDeclaredField(columnName); field.setAccessible(true); field.set(obj,value); } list.add((T)obj); } } catch (Exception e) { e.printStackTrace(); } finally { if (null !=resultSet) { try { resultSet.close(); } catch (SQLException e) { throw new RuntimeException(e); } } if (null != preparedStatement) { try { preparedStatement.close(); } catch (SQLException e) { throw new RuntimeException(e); } } JDBCUtil.releaseConnection(); } return list; } } 总结 数据库表名 $\\Longrightarrow$ POJO 类规范： 实体类类名和表格名称应该对应； 实体类属性名和表格列名应该对应； 属性必须私有； 每个属性必须具备 getter 和 setter（Lombok 插件）； 类必须具备无参构造器（Lombok 插件）； 应该重写类的 hashcode 和 equals 方法（Lombok 插件）； 类应该实现序列化接口（Serializable），因为缓存、分布式项目数据传递可能会将对象序列化； 根据需要重写 toString 方法。 Lombok 插件使用 使用 Lombok 插件可以生成 getter、setter、构造器、toString、hashcode 和 equals 方法。 安装 Lombok 插件 Settings -\u003e Build, Execution, Deployment -\u003e compiler -\u003e Annotation Processing -\u003e enable annotation processing -\u003e Apply, OK 下载 Lombok jar 包并导入至 WEB-INF 目录下的 lib 目录，然后 Add as Library (Module Level) DAO（Data Access Object）表示数据访问对象，该层用于定义操作数据库的 CRUD 方法。 在编写接口是需要给接口方法写上详细的文档： 类的文档注释（类的简介、作者、时间） 接口方法注释（方法简介、@param、@return） 面试题 什么是三层模型？它与 MVC 模型的区别是什么？\n--- title: 三层模型与 MVC 模型 --- graph subgraph presentation[表示层] view[View] ~~~ controller[Controller] end subgraph model[Model] dao[持久层] ~~~ service[业务层] end controller --\u003e service --\u003e controller service --\u003e dao --\u003e service dao --\u003e database[(数据库)] --\u003e dao 三层模型指的是表示层、业务层和持久层。它与 MVC 模型的区别在于关注点不同，三层模型关注业务逻辑组件的划分，MVC 模型关注的是整个应用程序的层次划分。\n","permalink":"https://signalyu.github.io/posts/tech/java-web/1-java-web-notes/","summary":"日程管理系统 MVC 模型 flowchart LR subgraph server[\"`**日程管理系统 MVC 模型**`\"] subgraph mysql[\"MySQL 数据库\"] direction TB subgraph tables[ ] subgraph userTable[sys_user 表] direction LR uid ~~~ username ~~~ userpwd end end end subgraph model[Model（模型层）] subgraph pojo[POJO] subgraph sysUserClass[SysUser.java] sysUserCode[\" private Integer uid; private String username; private String userPwd;\"] end end subgraph dao[DAO（持久层）] sysUserDao[SysUserDao 接口]~~~ baseDao[BaseDao 类] sysUserDao -.-\u003e sysUserDaoImpl[SysUserDaoImpl] baseDao --\u003e|继承| sysUserDaoImpl end subgraph service[Service（业务层）] sysUserService[SysUserService 接口] sysUserService -.-\u003e sysUserServiceImpl[SysUserServiceImpl] end end subgraph controller[Controller（与 View 构成表示层）] httpServlet[HttpServlet] ~~~ baseController[BaseController] ~~~ sysUserController[SysUserController] ~~~ utils[工具类] httpServlet -.","title":"Java Web 笔记"},{"content":" 子类对象拥有父类的私有成员，但子类不继承父类的私有属性。 子类对象包含父类私有属性 首先验证子类对象包含父类的私有属性，代码如下：\n点击查看代码 验证子类对象拥有父类私有成员 输出结果 class Parent { private int privateField; public Parent() { System.out.println(\"this in Parent() =\u003e \" + this); this.privateField = 666; } public Parent(int privateField) { System.out.println(\"this in Parent(int) =\u003e \" + this); this.privateField = privateField; } private void printPrivateField() { System.out.println(this.privateField); } public void accessPrivateMembers() { System.out.println(\"this in accessPrivateMembers() =\u003e \" + this); System.out.print(\"调用 this.printPrivateField() 方法 =\u003e \"); this.printPrivateField(); } } class Child extends Parent { public Child() { System.out.println(\"this in Child() =\u003e \" + this); } } public class Main { public static void main(String[] args) { Child child = new Child(); child.accessPrivateMembers(); } } this in Parent() =\u003e Child@372f7a8d this in Child() =\u003e Child@372f7a8d this in accessPrivateMembers() =\u003e Child@372f7a8d 调用 this.printPrivateField() 方法 =\u003e 666 上述代码的输出结果表明，执行 new Child() 后，会调用子类 Child 的无参构造器，而在子类构造器中默认会调用父类的无参构造器。而从输出结果可知，父类无参构造中的 this 指向子类 Child。并且 this.privateField = 666; 也成功执行。同样地，在调用公有（public）方法 accessPrivateMembers() 时，此时的 this 为 Child，并且通过 this 也可以访问父类的私有方法 printPrivateFields()。显然，this 中包含父类的私有属性 privateField 和私有方法 printPrivateField()。事实上，可以通过 org.openjdk.jol 工具中的 ClassLayout 来查看 child 对象在内存中的布局。代码如下：\n点击查看代码 查看对象内存布局 输出结果 import org.openjdk.jol.info.ClassLayout; class Parent { private int privateField; public Parent() { System.out.println(\"this in Parent() =\u003e \" + this); this.privateField = 666; } public Parent(int privateField) { System.out.println(\"this in Parent(int) =\u003e \" + this); this.privateField = privateField; } private void printPrivateField() { System.out.println(this.privateField); } public void accessPrivateMembers() { System.out.println(\"this in accessPrivateMembers() =\u003e \" + this); System.out.print(\"调用 this.printPrivateField() 方法 =\u003e \"); this.printPrivateField(); } } class Child extends Parent { public Child() { System.out.println(\"this in Child() =\u003e \" + this); } } public static void main(String[] args) { Child child = new Child(); String childLayout = ClassLayout.parseInstance(child).toPrintable(); System.out.println(childLayout); } Child object internals: OFF SZ TYPE DESCRIPTION VALUE 0 8 (object header: mark) 0x000000372f7a8d01 (hash: 0x372f7a8d; age: 0) 8 4 (object header: class) 0x01001418 12 4 int Parent.privateField 666 Instance size: 16 bytes Space losses: 0 bytes internal + 0 bytes external = 0 bytes total 根据上述输出结果可以看出，child 对象中确实包含父类的私有属性。\nJava 语言规范中关于类成员的规定 Java 类成员 Java 语言规范中关于类成的部分陈述如下：\n类的成员包括以下所有成员（The members of a class type are all of the following）：\n从除 Object 类之外的直接父类继承的成员（Members inherited from its direct superclass, except in class Object, which has no direct superclass） 从任何直接父接口继承的成员（Members inherited from any direct superinterfaces） 类中声明的成员（Members declared in the body of the class） 类中声明为私有的成员不会被该类的子类继承。（Members of a class that are declared private are not inherited by subclasses of that class.）\n只有声明为受保护（protected）或公共（public）的类成员才会被本包外的子类继承。（Only members of a class that are declared protected or public are inherited by subclasses declared in a package other than the one in which the class is declared.）\n构造器（constructors）、静态初始化器（static initializers）和实例初始化器（instance initializers）不是类成员，因此不会被继承。（Constructors, static initializers, and instance initializers are not members and therefore are not inherited.）\n超类的私有成员 Oracle 官方 Java 教程中关于超类的私有成员的说明：\n子类不继承父类的私有成员。不过，如果超类有访问其私有字段的公共或保护方法，子类也可以使用这些方法（间接访问父类的私有属性）。（A subclass does not inherit the private members of its parent class. However, if the superclass has public or protected methods for accessing its private fields, these can also be used by the subclass.）\n官方已明确说明子类不继承父类的私有成员，那为什么子类对象可以访问父类的私有成员呢？博主认为，继承是发生在类之间行为，而非对象之间的行为。子类 Child 不继承父类 Parent 的私有成员，并不代表子类对象 child 不可以拥有父类的私有成员。 参考资料 知乎：java中子类有没有继承父类的私有变量？ Java Language Specification : 8.2. Class Members Oracle Java Tutorial: Private Members in a Superclass Do subclasses inherit private fields? ","permalink":"https://signalyu.github.io/posts/tech/java/1-java-private-inheritance/","summary":"子类对象拥有父类的私有成员，但子类不继承父类的私有属性。 子类对象包含父类私有属性 首先验证子类对象包含父类的私有属性，代码如下：\n点击查看代码 验证子类对象拥有父类私有成员 输出结果 class Parent { private int privateField; public Parent() { System.out.println(\"this in Parent() =\u003e \" + this); this.privateField = 666; } public Parent(int privateField) { System.out.println(\"this in Parent(int) =\u003e \" + this); this.privateField = privateField; } private void printPrivateField() { System.out.println(this.privateField); } public void accessPrivateMembers() { System.out.println(\"this in accessPrivateMembers() =\u003e \" + this); System.out.print(\"调用 this.printPrivateField() 方法 =\u003e \"); this.printPrivateField(); } } class Child extends Parent { public Child() { System.","title":"Java 私有成员继承"}]