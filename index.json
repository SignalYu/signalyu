[{"content":"获取 Bean 的三种方式 id：bean 标签的标识，必须唯一 class：组件类的全类名 flowchart subgraph newIoc[新建 IoC 容器] newCtx[new ClassPathXmlApplicationContext] end subgraph ioc[IoC 容器] getBean1[\"`getBean(id)`\"] ~~~ getBean2[\"`getBean(class)`\"] ~~~ getBean3[\"`getBean(id, class)`\"] end subgraph beans[beans.xml] bean[\"`\u003c bean id=... class=包.类\u003e`\"] end subgraph userClass[User 类] user[\"`package .... class User {}`\"] end newCtx --\u003e|创建 IoC 容器|ioc bean -.- getBean1 \u0026 getBean2 \u0026 getBean3 userClass -.- bean 点击查看代码 beans.xml User.java TestUser.java \u0026lt;?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u0026lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"\u003e \u0026lt;bean id=\"user\" class=\"org.signalyu.spring6.iocxml.User\"\u003e\u0026lt;/bean\u003e \u0026lt;/beans\u003e package org.signalyu.spring6.iocxml; public class User { private String name; private Integer age; public void run() { System.out.println(\"Run...\"); } } package org.signalyu.spring6.iocxml; import org.springframework.context.ApplicationContext; import org.springframework.context.support.javaPathXmlApplicationContext; public class TestUser { public static void main(String[] args) { ApplicationContext context = new ClassPathXmlApplicationContext(\"beans.xml\"); // 基于 id 获取 Bean User user = (User)context.getBean(\"user\"); System.out.println(user); // 基于 class 获取 Bean User user2 = context.getBean(User.class); System.out.println(user2); // 基于 id 和 class 获取 Bean User user3 = context.getBean(\"user\",User.class); System.out.println(user3); } } 当根据类类型获取 bean 时，beans.xml 中的 bean 必须唯一。如果某个接口只被一个实现类实现，那么可以根据接口类型获取 bean。如果一个接口有多个实现类，并且都配置了 bean，这时通过接口类型获取 bean 将报错。 flowchart subgraph newIoc[新建 IoC 容器] newCtx[new ClassPathXmlApplicationContext] end subgraph ioc[IoC 容器] getBean[\"`getBean(class)`\"] end subgraph beans[beans.xml] bean1[\"`\u003c bean id=... class=包.Shape\u003e`\"] ~~~ bean2[\"`\u003c bean id=... class=包.Shape\u003e`\"] end subgraph shapeInterface[Shape 接口] shape[\"`package .... interface Shape {}`\"] end subgraph circleClass[Circle 类] circle[\"`package .... class Circle {}`\"] end subgraph rectangleClass[Rectangle 类] rectangle[\"`package .... class Rectangle {}`\"] end subgraph error[ ] err[根据 Shape 接口获取到两个不同的 bean] end newCtx --\u003e ioc circle \u0026 rectangle -.-\u003e shape shape --- bean1 \u0026 bean2 bean1 \u0026 bean2 -.- err --\u003e getBean 基于 Setter 进行依赖注入 \u0026lt;property name=\u0026#34;Class Field Name\u0026#34; value=\u0026#34;Class Field Value\u0026#34;/\u0026gt; 点击查看代码 beans.xml Course.java Student.java Main.java \u0026lt;?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u0026lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"\u003e \u0026lt;!-- Define the course bean --\u003e \u0026lt;bean id=\"course\" class=\"org.signalyu.spring6.iocxml.Course\"\u003e \u0026lt;property name=\"courseName\" value=\"Computer Science\"/\u003e \u0026lt;/bean\u003e \u0026lt;!-- Define the student bean --\u003e \u0026lt;bean id=\"student\" class=\"org.signalyu.spring6.iocxml.Student\"\u003e \u0026lt;!-- Inject the course dependency --\u003e \u0026lt;property name=\"course\" ref=\"course\"/\u003e \u0026lt;/bean\u003e \u0026lt;/beans\u003e package org.signalyu.spring6.iocxml; public class Course { private String courseName; public String getCourseName() { return courseName; } public void setCourseName(String courseName) { this.courseName = courseName; } } package org.signalyu.spring6.iocxml; public class Student { private Course course; public void setCourse(Course course) { this.course = course; } public void displayCourse() { System.out.println(\"Student is enrolled in: \" + course.getCourseName()); } } package org.signalyu.spring6.iocxml; import org.springframework.context.ApplicationContext; import org.springframework.context.support.javaPathXmlApplicationContext; public class Main { public static void main(String[] args) { ApplicationContext context = new ClassPathXmlApplicationContext(\"beans.xml\"); Student student = (Student) context.getBean(\"student\"); student.displayCourse(); } } 基于构造器进行依赖注入 \u0026lt;constructor-arg name=\u0026#34;Class Field Name\u0026#34; value=\u0026#34;Class Field Name\u0026#34;/\u0026gt; 点击查看代码 beans.xml Course.java Student.java Main.java \u0026lt;?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u0026lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"\u003e \u0026lt;!-- Define the course bean --\u003e \u0026lt;bean id=\"course\" class=\"org.signalyu.spring6.iocxml.Course\"\u003e \u0026lt;constructor-arg name=\"courseName\" value=\"Computer Science\"/\u003e \u0026lt;/bean\u003e \u0026lt;!-- Define the student bean --\u003e \u0026lt;bean id=\"student\" class=\"org.signalyu.spring6.iocxml.Student\"\u003e \u0026lt;!-- Inject the course dependency --\u003e \u0026lt;constructor-arg name=\"course\" ref=\"course\"/\u003e \u0026lt;/bean\u003e \u0026lt;/beans\u003e package org.signalyu.spring6.iocxml; public class Course { private String courseName; public Course(String courseName) { this.courseName = courseName; } public String getCourseName() { return courseName; } } package org.signalyu.spring6.iocxml; public class Student { private Course course; public Student(Course course) { this.course = course; } public void displayCourse() { System.out.println(\"Student is enrolled in: \" + course.getCourseName()); } } package org.signalyu.spring6.iocxml; import org.springframework.context.ApplicationContext; import org.springframework.context.support.javaPathXmlApplicationContext; public class Main { public static void main(String[] args) { ApplicationContext context = new ClassPathXmlApplicationContext(\"beans.xml\"); Student student = (Student) context.getBean(\"student\"); student.displayCourse(); } } beans.xml 特殊值处理 字面量赋值 使用 value 属性给 bean 的属性赋值时，Spring 会把 value 属性的值看做字面量。\n\u0026lt;bean id=\u0026#34;course\u0026#34; class=\u0026#34;org.signalyu.spring6.iocxml.Course\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;courseName\u0026#34; value=\u0026#34;Computer Science\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;!-- Define the Course bean using the p namespace --\u0026gt; \u0026lt;bean id=\u0026#34;course\u0026#34; class=\u0026#34;org.signalyu.spring6.iocxml.Course\u0026#34; p:courseName=\u0026#34;Computer Science\u0026#34;/\u0026gt; 上述定义中，Couputer Science 为 org.signalyu.spring6.iocxml.Course 类中的 courseName 属性的值。\nnull 值 \u0026lt;bean id=\u0026#34;course\u0026#34; class=\u0026#34;org.signalyu.spring6.iocxml.Course\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;courseName\u0026#34;\u0026gt; \u0026lt;null/\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; XML 实体与 CDATA 块 \u0026lt;!-- \u0026amp;lt; 表示 \u0026lt; --\u0026gt; \u0026lt;property name=\u0026#34;expression\u0026#34; value=\u0026#34;a \u0026amp;lt; b\u0026#34;/\u0026gt; \u0026lt;!-- CDATA 表示纯文本数据 --\u0026gt; \u0026lt;property name=\u0026#34;expression\u0026#34;\u0026gt; \u0026lt;value\u0026gt;\u0026lt;![CDATA[a \u0026lt; b]]\u0026gt;\u0026lt;/value\u0026gt; \u0026lt;/property\u0026gt; 为对象类型属性赋值 使用 ref 引用外部 bean \u0026lt;bean id=\u0026#34;course\u0026#34; class=\u0026#34;org.signalyu.spring6.iocxml.Course\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;courseName\u0026#34; value=\u0026#34;Computer Science\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;bean id=\u0026#34;student\u0026#34; class=\u0026#34;org.signalyu.spring6.iocxml.Student\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;course\u0026#34; ref=\u0026#34;course\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; 使用内部 bean 方式 \u0026lt;bean id=\u0026#34;student\u0026#34; class=\u0026#34;org.signalyu.spring6.iocxml.Student\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;course\u0026#34;\u0026gt; \u0026lt;bean class=\u0026#34;org.signalyu.spring6.iocxml.Course\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;courseName\u0026#34; value=\u0026#34;Computer Science\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; 使用工厂方法 点击查看代码 beans.xml CourseFactory.java Course.java Student.java Main.java \u0026lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"\u003e \u0026lt;!-- Define the CourseFactory bean --\u003e \u0026lt;bean id=\"courseFactory\" class=\"org.signalyu.spring6.iocxml.CourseFactory\"/\u003e \u0026lt;!-- Define the Student bean --\u003e \u0026lt;bean id=\"student\" class=\"org.signalyu.spring6.iocxml.Student\"\u003e \u0026lt;!-- Inject the Course using factory method --\u003e \u0026lt;property name=\"course\"\u003e \u0026lt;bean factory-bean=\"courseFactory\" factory-method=\"createCourse\"/\u003e \u0026lt;/property\u003e \u0026lt;/bean\u003e \u0026lt;/beans\u003e package org.signalyu.spring6.iocxml; public class CourseFactory { public static Course createCourse() { return new Course(\"Computer Science\"); } } package org.signalyu.spring6.iocxml; public class Course { private String courseName; public Course(String courseName) { this.courseName = courseName; } public String getCourseName() { return courseName; } @Override public String toString() { return \"Course{\" + \"courseName='\" + courseName + '\\'' + '}'; } } package org.signalyu.spring6.iocxml; public class Student { private Course course; public void setCourse(Course course) { this.course = course; } public void displayCourse() { System.out.println(\"Student is enrolled in: \" + course.getCourseName()); } } package org.signalyu.spring6.iocxml; import org.springframework.context.ApplicationContext; import org.springframework.context.support.javaPathXmlApplicationContext; public class Main { public static void main(String[] args) { ApplicationContext context = new ClassPathXmlApplicationContext(\"beans.xml\"); Student student = (Student) context.getBean(\"student\"); student.displayCourse(); } } 为数组/集合类型赋值 数组类型使用 array 标签，集合类型可使用 list 或者 set 标签。 点击查看代码 beans.xml Course.java Student.java Main.java \u0026lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"\u003e \u0026lt;!-- Define the Student bean --\u003e \u0026lt;bean id=\"student\" class=\"org.signalyu.spring6.iocxml.Student\"\u003e \u0026lt;!-- Assign values to the courses property --\u003e \u0026lt;property name=\"courses\"\u003e \u0026lt;array\u003e \u0026lt;value\u003eMath\u0026lt;/value\u003e \u0026lt;value\u003eScience\u0026lt;/value\u003e \u0026lt;value\u003eHistory\u0026lt;/value\u003e \u0026lt;/array\u003e \u0026lt;/property\u003e \u0026lt;/bean\u003e \u0026lt;/beans\u003e package org.signalyu.spring6.iocxml; public class Course { private String courseName; public void setCourseName(String courseName) { this.courseName = courseName; } } package org.signalyu.spring6.iocxml; public class Student { private String[] courses; public void setCourses(String[] courses) { this.courses = courses; } public String[] getCourses() { return courses; } } package org.signalyu.spring6.iocxml; import org.springframework.context.ApplicationContext; import org.springframework.context.support.ClassPathXmlApplicationContext; public class Main { public static void main(String[] args) { ApplicationContext context = new ClassPathXmlApplicationContext(\"beans.xml\"); Student student = (Student) context.getBean(\"student\"); // Display the courses System.out.println(\"Student is enrolled in the following courses:\"); for (String course : student.getCourses()) { System.out.println(\"- \" + course); } } } 为 Map 类型赋值 点击查看代码 beans.xml Student.java Main.java \u0026lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"\u003e \u0026lt;!-- Define the Student bean --\u003e \u0026lt;bean id=\"student\" class=\"org.signalyu.spring6.iocxml.Student\"\u003e \u0026lt;!-- Assign values to the courseGrades property using a Map --\u003e \u0026lt;property name=\"courseGrades\"\u003e \u0026lt;map\u003e \u0026lt;entry key=\"Math\" value=\"90\"/\u003e \u0026lt;entry key=\"Science\" value=\"85\"/\u003e \u0026lt;entry key=\"History\" value=\"88\"/\u003e \u0026lt;/map\u003e \u0026lt;/property\u003e \u0026lt;/bean\u003e \u0026lt;/beans\u003e package org.signalyu.spring6.iocxml; import java.util.Map; public class Student { private Map courseGrades; public void setCourseGrades(Map courseGrades) { this.courseGrades = courseGrades; } public Map getCourseGrades() { return courseGrades; } } package org.signalyu.spring6.iocxml; import org.springframework.context.ApplicationContext; import org.springframework.context.support.ClassPathXmlApplicationContext; public class Main { public static void main(String[] args) { ApplicationContext context = new ClassPathXmlApplicationContext(\"beans.xml\"); // Retrieve the student bean from the Spring IoC container Student student = (Student) context.getBean(\"student\"); // Display course grades System.out.println(\"Course Grades:\"); student.getCourseGrades().forEach((course, grade) -\u003e System.out.println(course + \": \" + grade) ); } } 引入外部属性文件 点击查看代码 beanJdbc.xml jdbc.properties TestJdbc.java \u0026lt;?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u0026lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\"\u003e \u0026lt;!--引入外部属性文件之前需要在 beans 标签中添加 context 相关的约束--\u003e \u0026lt;!-- 引入外部属性文件 --\u003e \u0026lt;context:property-placeholder location=\"classpath:jdbc.properties\"/\u003e \u0026lt;bean id=\"druidDataSource\" class=\"com.alibaba.druid.pool.DruidDataSource\"\u003e \u0026lt;property name=\"url\" value=\"${jdbc.url}\"/\u003e \u0026lt;property name=\"driverClassName\" value=\"${jdbc.driver}\"/\u003e \u0026lt;property name=\"username\" value=\"${jdbc.user}\"/\u003e \u0026lt;property name=\"password\" value=\"${jdbc.password}\"/\u003e \u0026lt;/bean\u003e \u0026lt;/beans\u003e jdbc.user=root jdbc.password=root jdbc.url=jdbc:mysql://localhost:3306 jdbc.driver=com.mysql.cj.jdbc.Driver import org.junit.jupiter.api.Test; import org.springframework.context.ApplicationContext; import org.springframework.context.support.ClassPathXmlApplicationContext; import javax.sql.DataSource; import java.sql.Connection; import java.sql.SQLException; public class TestJdbc { @Test public void testDataSource() throws SQLException { ApplicationContext ac = new ClassPathXmlApplicationContext(\"beansJdbc.xml\"); DataSource dataSource = ac.getBean(DataSource.class); Connection connection = dataSource.getConnection(); System.out.println(connection); } } bean 的作用域 bean 标签的 scope 属性可以指定 bean 的作用域范围，常用值为 singleton（默认） 和 prototype。当作用域范围为 singleton 时，bean 对象在 IoC 容器初始化时创建，且只有一个；当作用域范围为 prototype 时，bean 对象在获取执行 getBean 时创建，IoC 容器中存在多个不同的 bean 实例。\n点击查看代码 beans.xml SingletonBean.java PrototypeBean.java TestBeanScope.java 测试结果 \u0026lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"\u003e \u0026lt;!-- Singleton scope (default) --\u003e \u0026lt;bean id=\"singletonBean\" class=\"org.signalyu.spring6.iocxml.SingletonBean\" /\u003e \u0026lt;!-- Prototype scope --\u003e \u0026lt;bean id=\"prototypeBean\" class=\"org.signalyu.spring6.iocxml.PrototypeBean\" scope=\"prototype\" /\u003e \u0026lt;/beans\u003e package org.signalyu.spring6.iocxml; public class SingletonBean { private String message; public SingletonBean() { this.message = \"SingletonBean instance created\"; } public void setMessage(String message) { this.message = message; } public String getMessage() { return message; } } package org.signalyu.spring6.iocxml; public class PrototypeBean { private String message; public PrototypeBean() { this.message = \"PrototypeBean instance created\"; } public void setMessage(String message) { this.message = message; } public String getMessage() { return message; } } import org.junit.jupiter.api.Test; import org.signalyu.spring6.iocxml.SingletonBean; import org.signalyu.spring6.iocxml.PrototypeBean; import org.springframework.context.ApplicationContext; import org.springframework.context.support.ClassPathXmlApplicationContext; public class TestBeanScope { @Test public void testBeanScope(){ ApplicationContext context = new ClassPathXmlApplicationContext(\"beans.xml\"); // Retrieve singletonBean and prototypeBean from the Spring IoC container SingletonBean singletonBean1 = context.getBean(\"singletonBean\", SingletonBean.class); SingletonBean singletonBean2 = context.getBean(\"singletonBean\", SingletonBean.class); PrototypeBean prototypeBean1 = context.getBean(\"prototypeBean\", PrototypeBean.class); PrototypeBean prototypeBean2 = context.getBean(\"prototypeBean\", PrototypeBean.class); // Change the message for both beans System.out.println(\"Modify the message of singletonBean1~~~\"); singletonBean1.setMessage(\"Singleton bean modified\"); System.out.println(\"Modify the message of prototypeBean1~~~\"); prototypeBean1.setMessage(\"Prototype bean modified\"); // Display the messages for both beans System.out.println(\"Singleton Bean 1: \" + singletonBean1.getMessage()); System.out.println(\"Singleton Bean 2: \" + singletonBean2.getMessage()); System.out.println(\"Prototype Bean 1: \" + prototypeBean1.getMessage()); System.out.println(\"Prototype Bean 2: \" + prototypeBean2.getMessage()); } } 2024-05-09 19:05:39 466 [main] DEBUG org.springframework.context.support.ClassPathXmlApplicationContext - Refreshing org.springframework.context.support.ClassPathXmlApplicationContext@531c311e 2024-05-09 19:05:39 554 [main] DEBUG org.springframework.beans.factory.xml.XmlBeanDefinitionReader - Loaded 2 bean definitions from class path resource [beans.xml] 2024-05-09 19:05:39 572 [main] DEBUG org.springframework.beans.factory.support.DefaultListableBeanFactory - Creating shared instance of singleton bean 'singletonBean' Modify the message of singletonBean1~~~ Modify the message of prototypeBean1~~~ Singleton Bean 1: Singleton bean modified Singleton Bean 2: Singleton bean modified Prototype Bean 1: Prototype bean modified Prototype Bean 2: PrototypeBean instance created Bean 生命周期 点击查看代码 beans.xml User.java BeanProcessor.java TestLifecycle.java 测试结果 \u0026lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"\u003e \u0026lt;bean id=\"user\" class=\"org.signalyu.spring6.iocxml.User\" init-method=\"initMethod\" destroy-method=\"destroyMethod\"\u003e \u0026lt;property name=\"id\" value=\"1\"/\u003e \u0026lt;property name=\"username\" value=\"testuser\"/\u003e \u0026lt;property name=\"password\" value=\"password\"/\u003e \u0026lt;property name=\"age\" value=\"30\"/\u003e \u0026lt;/bean\u003e \u0026lt;bean class=\"org.signalyu.spring6.iocxml.BeanProcessor\"/\u003e \u0026lt;/beans\u003e package org.signalyu.spring6.iocxml; public class User { private Integer id; private String username; private String password; private Integer age; public User() { System.out.println(\"Lifecycle: 1. Creating object\"); } public User(Integer id, String username, String password, Integer age) { this.id = id; this.username = username; this.password = password; this.age = age; } public Integer getId() { return id; } public void setId(Integer id) { System.out.println(\"Lifecycle: 2. Dependency injection\"); this.id = id; } public String getUsername() { return username; } public void setUsername(String username) { this.username = username; } public String getPassword() { return password; } public void setPassword(String password) { this.password = password; } public Integer getAge() { return age; } public void setAge(Integer age) { this.age = age; } public void initMethod(){ System.out.println(\"Lifecycle: 4. Initializing\"); } public void destroyMethod(){ System.out.println(\"Lifecycle: 7. Destroying\"); } @Override public String toString() { return \"User{\" + \"id=\" + id + \", username='\" + username + '\\'' + \", password='\" + password + '\\'' + \", age=\" + age + '}'; } } package org.signalyu.spring6.iocxml; import org.springframework.beans.BeansException; import org.springframework.beans.factory.config.BeanPostProcessor; public class BeanProcessor implements BeanPostProcessor { @Override public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException { System.out.println(\"Lifecycle 3: Before initialization\"); return bean; } @Override public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException { System.out.println(\"Lifecycle 5: After initialization\"); return bean; } } import org.junit.jupiter.api.Test; import org.signalyu.spring6.iocxml.User; import org.springframework.context.support.ClassPathXmlApplicationContext; public class TestLifecycle { @Test public void testLifeCycle(){ ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(\"beans.xml\"); User user = context.getBean(User.class); System.out.println(\"Lifecycle: 6. Using bean obtained from the IOC container\"); context.close(); System.out.println(\"Lifecycle: 8. IoC container closed\"); } } Lifecycle: 1. Creating object Lifecycle: 2. Dependency injection Lifecycle 3: Before initialization Lifecycle: 4. Initializing Lifecycle 5: After initialization Lifecycle: 6. Using bean obtained from the IOC container 2024-05-09 21:19:27 785 [main] DEBUG org.springframework.context.support.ClassPathXmlApplicationContext - Closing org.springframework.context.support.ClassPathXmlApplicationContext@531c311e, started on Thu May 09 21:19:27 HKT 2024 Lifecycle: 7. Destroying 2024-05-09 21:19:27 786 [main] DEBUG org.springframework.beans.factory.support.DisposableBeanAdapter - Custom destroy method 'destroyMethod' on bean with name 'user' completed Lifecycle: 8. IoC container closed bean 的后置处理器会在生命周期的初始化前后添加额外的操作。需要注意的是，bean 后置处理器对 IOC 容器中所有 bean 都会生效。 FactoryBean 点击查看代码 beans.xml Car.java CarFactoryBean.java TestFactoryBean.java \u0026lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"\u003e \u0026lt;bean id=\"carFactory\" class=\"org.signalyu.spring6.iocxml.CarFactoryBean\"\u003e \u0026lt;constructor-arg value=\"Porsche\"/\u003e \u0026lt;constructor-arg value=\"BruBus\"/\u003e \u0026lt;/bean\u003e \u0026lt;/beans\u003e package org.signalyu.spring6.iocxml; public class Car { private String brand; private String model; public Car(String brand, String model) { this.brand = brand; this.model = model; } @Override public String toString() { return \"Car{\" + \"brand='\" + brand + '\\'' + \", model='\" + model + '\\'' + '}'; } } package org.signalyu.spring6.iocxml; import org.springframework.beans.factory.FactoryBean; public class CarFactoryBean implements FactoryBean { private String brand; private String model; public CarFactoryBean(String brand, String model) { this.brand = brand; this.model = model; } @Override public Car getObject() throws Exception { // Create a new instance of Car using the provided brand and model return new Car(brand, model); } @Override public Class\u003c?\u003e getObjectType() { return Car.class; } @Override public boolean isSingleton() { return false; // Returning false to indicate that Car instances are not singleton } } import org.junit.jupiter.api.Test; import org.signalyu.spring6.iocxml.Car; import org.springframework.context.ApplicationContext; import org.springframework.context.support.ClassPathXmlApplicationContext; public class TestFactoryBean { @Test public void testFactoryBean() { ApplicationContext context = new ClassPathXmlApplicationContext(\"beans.xml\"); Car car = context.getBean(\"carFactory\", Car.class); System.out.println(\"car = \" + car); } } flowchart subgraph beans[beans.xml] bean[\u0026lt; bean ...\u0026gt;] end subgraph carFactoryBean[CarFactoryBean] factoryMethod1[getObject] ~~~ factoryMethod2[getObjectType] ~~~ ... end subgraph ioc[IoC 容器] getBean end ioc --\u003e|create| carFactoryBean -.- bean -.-\u003e ioc carFactoryBean ---\u003e|create| Car 自动装配（Autowire） 点击查看代码 自动装配 ref 内部 bean \u0026lt;bean id=\"employee\" class=\"org.signalyu.spring6.iocxml.Student\" autowire=\"byType\"\u003e\u0026lt;/bean\u003e \u0026lt;bean id=\"address\" class=\"org.signalyu.spring6.iocxml.Course\"\u003e \u0026lt;constructor-arg value=\"Computer Science\"/\u003e \u0026lt;/bean\u003e \u0026lt;bean id=\"course\" class=\"org.signalyu.spring6.iocxml.Course\"\u003e \u0026lt;property name=\"courseName\" value=\"Computer Science\"/\u003e \u0026lt;/bean\u003e \u0026lt;bean id=\"student\" class=\"org.signalyu.spring6.iocxml.Student\"\u003e \u0026lt;property name=\"course\" ref=\"course\"/\u003e \u0026lt;/bean\u003e \u0026lt;bean id=\"student\" class=\"org.signalyu.spring6.iocxml.Student\"\u003e \u0026lt;property name=\"course\"\u003e \u0026lt;bean class=\"org.signalyu.spring6.iocxml.Course\"\u003e \u0026lt;property name=\"courseName\" value=\"Computer Science\"/\u003e \u0026lt;/bean\u003e \u0026lt;/property\u003e \u0026lt;/bean\u003e ","permalink":"https://signalyu.github.io/posts/tech/0005-bean-management-base-on-xml/","summary":"获取 Bean 的三种方式 id：bean 标签的标识，必须唯一 class：组件类的全类名 flowchart subgraph newIoc[新建 IoC 容器] newCtx[new ClassPathXmlApplicationContext] end subgraph ioc[IoC 容器] getBean1[\"`getBean(id)`\"] ~~~ getBean2[\"`getBean(class)`\"] ~~~ getBean3[\"`getBean(id, class)`\"] end subgraph beans[beans.xml] bean[\"`\u003c bean id=... class=包.类\u003e`\"] end subgraph userClass[User 类] user[\"`package .... class User {}`\"] end newCtx --\u003e|创建 IoC 容器|ioc bean -.- getBean1 \u0026 getBean2 \u0026 getBean3 userClass -.- bean 点击查看代码 beans.xml User.java TestUser.java \u0026lt;?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u0026lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"\u003e \u0026lt;bean id=\"user\" class=\"org.signalyu.spring6.iocxml.User\"\u003e\u0026lt;/bean\u003e \u0026lt;/beans\u003e package org.","title":"Spring：基于 XML 管理 Bean"},{"content":"日程管理系统 MVC 模型 flowchart LR subgraph server[\"`**日程管理系统 MVC 模型**`\"] subgraph mysql[\"MySQL 数据库\"] direction TB subgraph tables[ ] subgraph userTable[sys_user 表] direction LR uid ~~~ username ~~~ userpwd end end end subgraph model[Model（模型层）] subgraph pojo[POJO] subgraph sysUserClass[SysUser.java] sysUserCode[\" private Integer uid; private String username; private String userPwd;\"] end end subgraph dao[DAO（持久层）] sysUserDao[SysUserDao 接口]~~~ baseDao[BaseDao 类] sysUserDao -.-\u003e sysUserDaoImpl[SysUserDaoImpl] baseDao --\u003e|继承| sysUserDaoImpl end subgraph service[Service（业务层）] sysUserService[SysUserService 接口] sysUserService -.-\u003e sysUserServiceImpl[SysUserServiceImpl] end end subgraph controller[Controller（与 View 构成表示层）] httpServlet[HttpServlet] ~~~ baseController[BaseController] ~~~ sysUserController[SysUserController] ~~~ utils[工具类] httpServlet -.-\u003e|实现| baseController --\u003e|继承| sysUserController utils -.-\u003e|使用| sysUserController end subgraph view[View（视图层）] html ~~~ css ~~~ js ~~~ others[...] end subgraph client[客户端] end end sysUserClass -.- sysUserDaoImpl userTable ==\u003e baseDao baseDao ==\u003e userTable sysUserClass -.-\u003e|使用| sysUserServiceImpl sysUserClass -.-\u003e|使用| sysUserController sysUserController ==\u003e|操作|sysUserServiceImpl ==\u003e|操作| sysUserDaoImpl client --\u003e|Request| sysUserController sysUserController --\u003e|Response| client controller --\u003e|更新| view --\u003e|展示| client 部分参考代码 flowchart SysUserController ==\u003e|调用| SysUserServiceImpl ==\u003e|调用| SysUserDaoImpl ==\u003e|调用| BaseDao --\u003e|操作| database[(数据库)] 点击查看代码 SysUserController SysUserServiceImpl SysUserDaoImpl BaseDao protected void login(HttpServletRequest req, HttpServletResponse resp) throws IOException { // 1. 接收用户名和密码 String username = req.getParameter(\"username\"); String userPwd = req.getParameter(\"userPwd\"); // 2. 调用服务层方法，根据用户名查询用户信息 SysUser loginUser = userService.findByUsername(username); if (loginUser == null) { resp.sendRedirect(\"/loginUsernameError.html\"); } else if (!MD5Util.encrypt(userPwd).equals(loginUser.getUserPwd())) { // 3. 判断密码是否匹配 resp.sendRedirect(\"/loginUserPwdError.html\"); } else { // 登录成功之后，将登录的信息放入session HttpSession session = req.getSession(); session.setAttribute(\"sysUser\", loginUser); // 4. 跳转到首页 resp.sendRedirect(\"/showSchedule.html\"); } } public class SysUserServiceImpl implements SysUserService { // ... @Override public SysUser findByUsername(String username) { return userDao.findByUsername(username); } } public class SysUserDaoImpl extends BaseDao implements SysUserDao { // ... @Override public SysUser findByUsername(String username) { String sql = \"select uid, username, user_pwd userPwd from sys_user where username = ?\"; List sysUserList = baseQuery(SysUser.class, sql, username); return sysUserList != null \u0026\u0026 sysUserList.size() != 0 ? sysUserList.get(0) : null; } } public class BaseDao { public List baseQuery(Class clazz, String sql, Object ... args){ List list =new ArrayList\u003c\u003e(); Connection connection = JDBCUtil.getConnection(); PreparedStatement preparedStatement=null; ResultSet resultSet =null; int rows = 0; try { // 准备语句对象 preparedStatement = connection.prepareStatement(sql); // 设置语句上的参数 for (int i = 0; i \u003c args.length; i++) { preparedStatement.setObject(i+1,args[i]); } // 执行 查询 resultSet = preparedStatement.executeQuery(); ResultSetMetaData metaData = resultSet.getMetaData(); int columnCount = metaData.getColumnCount(); // 将结果集通过反射封装成实体类对象 while (resultSet.next()) { // 使用反射实例化对象 Object obj =clazz.getDeclaredConstructor().newInstance(); for (int i = 1; i \u003c= columnCount; i++) { String columnName = metaData.getColumnLabel(i); Object value = resultSet.getObject(columnName); // 处理datetime类型字段和java.util.Data转换问题 if(value.getClass().equals(LocalDateTime.class)){ value= Timestamp.valueOf((LocalDateTime) value); } Field field = clazz.getDeclaredField(columnName); field.setAccessible(true); field.set(obj,value); } list.add((T)obj); } } catch (Exception e) { e.printStackTrace(); } finally { if (null !=resultSet) { try { resultSet.close(); } catch (SQLException e) { throw new RuntimeException(e); } } if (null != preparedStatement) { try { preparedStatement.close(); } catch (SQLException e) { throw new RuntimeException(e); } } JDBCUtil.releaseConnection(); } return list; } } 总结 数据库表名 $\\Longrightarrow$ POJO 类规范： 实体类类名和表格名称应该对应； 实体类属性名和表格列名应该对应； 属性必须私有； 每个属性必须具备 getter 和 setter（Lombok 插件）； 类必须具备无参构造器（Lombok 插件）； 应该重写类的 hashcode 和 equals 方法（Lombok 插件）； 类应该实现序列化接口（Serializable），因为缓存、分布式项目数据传递可能会将对象序列化； 根据需要重写 toString 方法。 Lombok 插件使用 使用 Lombok 插件可以生成 getter、setter、构造器、toString、hashcode 和 equals 方法。 安装 Lombok 插件 Settings -\u003e Build, Execution, Deployment -\u003e compiler -\u003e Annotation Processing -\u003e enable annotation processing -\u003e Apply, OK 下载 Lombok jar 包并导入至 WEB-INF 目录下的 lib 目录，然后 Add as Library (Module Level) DAO（Data Access Object）表示数据访问对象，该层用于定义操作数据库的 CRUD 方法。 在编写接口是需要给接口方法写上详细的文档： 类的文档注释（类的简介、作者、时间） 接口方法注释（方法简介、@param、@return） 面试题 什么是三层模型？它与 MVC 模型的区别是什么？\n--- title: 三层模型与 MVC 模型 --- graph subgraph presentation[表示层] view[View] ~~~ controller[Controller] end subgraph model[Model] dao[持久层] ~~~ service[业务层] end controller --\u003e service --\u003e controller service --\u003e dao --\u003e service dao --\u003e database[(数据库)] --\u003e dao 三层模型指的是表示层、业务层和持久层。它与 MVC 模型的区别在于关注点不同，三层模型关注业务逻辑组件的划分，MVC 模型关注的是整个应用程序的层次划分。\n","permalink":"https://signalyu.github.io/posts/tech/0002-java-web-notes/","summary":"日程管理系统 MVC 模型 flowchart LR subgraph server[\"`**日程管理系统 MVC 模型**`\"] subgraph mysql[\"MySQL 数据库\"] direction TB subgraph tables[ ] subgraph userTable[sys_user 表] direction LR uid ~~~ username ~~~ userpwd end end end subgraph model[Model（模型层）] subgraph pojo[POJO] subgraph sysUserClass[SysUser.java] sysUserCode[\" private Integer uid; private String username; private String userPwd;\"] end end subgraph dao[DAO（持久层）] sysUserDao[SysUserDao 接口]~~~ baseDao[BaseDao 类] sysUserDao -.-\u003e sysUserDaoImpl[SysUserDaoImpl] baseDao --\u003e|继承| sysUserDaoImpl end subgraph service[Service（业务层）] sysUserService[SysUserService 接口] sysUserService -.-\u003e sysUserServiceImpl[SysUserServiceImpl] end end subgraph controller[Controller（与 View 构成表示层）] httpServlet[HttpServlet] ~~~ baseController[BaseController] ~~~ sysUserController[SysUserController] ~~~ utils[工具类] httpServlet -.","title":"Java Web 笔记"},{"content":"Java 中子类是否继承父类的私有属性？大家的疑惑无非是：如果子类不继承父类的私有属性，那子类对象为什么包含父类的私有属性？博主之前也同样疑惑，在查阅了相关资料后，得出如下结论：\n子类对象确实存在父类的私有属性，但子类不继承父类的私有属性。\n子类对象包含父类私有属性 首先，博主先验证子类对象包含父类的私有属性，代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 class Parent { private int privateField; public Parent() { System.out.println(\u0026#34;this in Parent() =\u0026gt; \u0026#34; + this); this.privateField = 666; } public Parent(int privateField) { System.out.println(\u0026#34;this in Parent(int) =\u0026gt; \u0026#34; + this); this.privateField = privateField; } private void printPrivateField() { System.out.println(this.privateField); } public void accessPrivateMembers() { System.out.println(\u0026#34;this in accessPrivateMembers() =\u0026gt; \u0026#34; + this); System.out.print(\u0026#34;调用 this.printPrivateField() 方法 =\u0026gt; \u0026#34;); this.printPrivateField(); } } class Child extends Parent { public Child() { System.out.println(\u0026#34;this in Child() =\u0026gt; \u0026#34; + this); } } public class Main { public static void main(String[] args) { Child child = new Child(); child.accessPrivateMembers(); } } 上述代码的输出结果如下：\nthis in Parent() =\u0026gt; Child@372f7a8d this in Child() =\u0026gt; Child@372f7a8d this in accessPrivateMembers() =\u0026gt; Child@372f7a8d 调用 this.printPrivateField() 方法 =\u0026gt; 666 上述代码中，执行 new Child() 后，会调用子类 Child 的无参构造器，而在子类构造器中默认会调用父类的无参构造器。而从输出结果可知，父类无参构造中的 this 指向子类 Child。并且 this.privateField = 666; 也成功执行。同样地，在调用公有（public）方法 accessPrivateMembers() 时，此时的 this 为 Child，并且通过 this 也可以访问父类的私有方法 printPrivateFields()。显然，this 中包含父类的私有属性 privateField 和私有方法 printPrivateField()。事实上，我们可以通过 org.openjdk.jol 工具中的 ClassLayout 来查看 child 对象在内存中的布局。代码如下：\n1 2 3 4 5 6 7 import org.openjdk.jol.info.ClassLayout; public static void main(String[] args) { Child child = new Child(); String childLayout = ClassLayout.parseInstance(child).toPrintable(); System.out.println(childLayout); } 上述代码输出结果为：\nChild object internals: OFF SZ TYPE DESCRIPTION VALUE 0 8 (object header: mark) 0x000000372f7a8d01 (hash: 0x372f7a8d; age: 0) 8 4 (object header: class) 0x01001418 12 4 int Parent.privateField 666 Instance size: 16 bytes Space losses: 0 bytes internal + 0 bytes external = 0 bytes total 根据上述输出结果可以看出，child 对象中确实包含父类的私有属性。\n那么问题来了，如果子类对象不继承父类的私有属性，那为什么子类可以通过 this 访问到父类的私有属性。在回答这个问题之前，我们先来看 Java 语言规范中关于类成员的规定。\nJava 类成员 Java 语言规范中关于类成的部分陈述如下：\n类的成员包括以下所有成员（The members of a class type are all of the following）：\n从除 Object 类之外的直接父类继承的成员（Members inherited from its direct superclass, except in class Object, which has no direct superclass） 从任何直接父接口继承的成员（Members inherited from any direct superinterfaces） 类中声明的成员（Members declared in the body of the class） 类中声明为私有的成员不会被该类的子类继承。（Members of a class that are declared private are not inherited by subclasses of that class.）\n只有声明为受保护（protected）或公共（public）的类成员才会被本包外的子类继承。（Only members of a class that are declared protected or public are inherited by subclasses declared in a package other than the one in which the class is declared.）\n构造器（constructors）、静态初始化器（static initializers）和实例初始化器（instance initializers）不是类成员，因此不会被继承。（Constructors, static initializers, and instance initializers are not members and therefore are not inherited.）\n超类的私有成员 了解完 Java 类成员后，再来看 Oracle 官方 Java 教程中关于超类的私有成员的说明：\n子类不继承父类的私有成员。不过，如果超类有访问其私有字段的公共或保护方法，子类也可以使用这些方法（间接访问父类的私有属性）。（A subclass does not inherit the private members of its parent class. However, if the superclass has public or protected methods for accessing its private fields, these can also be used by the subclass.）\n官方已明确说明子类不继承父类的私有成员，那为什么子类对象可以访问父类的私有成员呢？ 博主认为，继承是发生在类之间行为，而非对象之间的行为。子类 Child 不继承父类 Parent 的私有成员，并不代表子类对象 child 不可以拥有父类的属性。\n综上所述，子类不继承父类的私有成员，但子类对象包含父类的私有成员，并且可以通过父类提供的公有（public）或受保护（protected）方法来访问。\n参考资料 知乎：java中子类有没有继承父类的私有变量？ Java Language Specification : 8.2. Class Members Oracle Java Tutorial: Private Members in a Superclass Do subclasses inherit private fields? ","permalink":"https://signalyu.github.io/posts/tech/0001-java-private-inheritance/","summary":"Java 中子类是否继承父类的私有属性？大家的疑惑无非是：如果子类不继承父类的私有属性，那子类对象为什么包含父类的私有属性？博主之前也同样疑惑，在查阅了相关资料后，得出如下结论：\n子类对象确实存在父类的私有属性，但子类不继承父类的私有属性。\n子类对象包含父类私有属性 首先，博主先验证子类对象包含父类的私有属性，代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 class Parent { private int privateField; public Parent() { System.out.println(\u0026#34;this in Parent() =\u0026gt; \u0026#34; + this); this.privateField = 666; } public Parent(int privateField) { System.out.println(\u0026#34;this in Parent(int) =\u0026gt; \u0026#34; + this); this.","title":"Java 中父类的私有属性可以被子类继承吗？"}]