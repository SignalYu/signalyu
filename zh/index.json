[{"content":"Java 中子类是否继承父类的私有属性？大家的疑惑无非是：如果子类不继承父类的私有属性，那子类对象为什么包含父类的私有属性？博主之前也同样疑惑，在查阅了相关资料后，得出如下结论：\n子类对象确实存在父类的私有属性，但子类不继承父类的私有属性。\n子类对象包含父类私有属性 首先，博主先验证子类对象包含父类的私有属性，代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 class Parent { private int privateField; public Parent() { System.out.println(\u0026#34;this in Parent() =\u0026gt; \u0026#34; + this); this.privateField = 666; } public Parent(int privateField) { System.out.println(\u0026#34;this in Parent(int) =\u0026gt; \u0026#34; + this); this.privateField = privateField; } private void printPrivateField() { System.out.println(this.privateField); } public void accessPrivateMembers() { System.out.println(\u0026#34;this in accessPrivateMembers() =\u0026gt; \u0026#34; + this); System.out.print(\u0026#34;调用 this.printPrivateField() 方法 =\u0026gt; \u0026#34;); this.printPrivateField(); } } class Child extends Parent { public Child() { System.out.println(\u0026#34;this in Child() =\u0026gt; \u0026#34; + this); } } public class Main { public static void main(String[] args) { Child child = new Child(); child.accessPrivateMembers(); } } 上述代码的输出结果如下：\nthis in Parent() =\u0026gt; Child@372f7a8d this in Child() =\u0026gt; Child@372f7a8d this in accessPrivateMembers() =\u0026gt; Child@372f7a8d 调用 this.printPrivateField() 方法 =\u0026gt; 666 上述代码中，执行 new Child() 后，会调用子类 Child 的无参构造器，而在子类构造器中默认会调用父类的无参构造器。而从输出结果可知，父类无参构造中的 this 指向子类 Child。并且 this.privateField = 666; 也成功执行。同样地，在调用公有（public）方法 accessPrivateMembers() 时，此时的 this 为 Child，并且通过 this 也可以访问父类的私有方法 printPrivateFields()。显然，this 中包含父类的私有属性 privateField 和私有方法 printPrivateField()。事实上，我们可以通过 org.openjdk.jol 工具中的 ClassLayout 来查看 child 对象在内存中的布局。代码如下：\n1 2 3 4 5 6 7 import org.openjdk.jol.info.ClassLayout; public static void main(String[] args) { Child child = new Child(); String childLayout = ClassLayout.parseInstance(child).toPrintable(); System.out.println(childLayout); } 上述代码输出结果为：\n1 2 3 4 5 6 7 Child object internals: OFF SZ TYPE DESCRIPTION VALUE 0 8 (object header: mark) 0x000000372f7a8d01 (hash: 0x372f7a8d; age: 0) 8 4 (object header: class) 0x01001418 12 4 int Parent.privateField 666 Instance size: 16 bytes Space losses: 0 bytes internal + 0 bytes external = 0 bytes total 根据上述输出结果可以看出，child 对象中确实包含父类的私有属性。\n那么问题来了，如果子类对象不继承父类的私有属性，那为什么子类可以通过 this 访问到父类的私有属性。在回答这个问题之前，我们先来看 Java 语言规范中关于类成员的规定。\nJava 类成员 Java 语言规范中关于类成的部分陈述如下：\n类的成员包括以下所有成员（The members of a class type are all of the following）：\n从除 Object 类之外的直接父类继承的成员（Members inherited from its direct superclass, except in class Object, which has no direct superclass） 从任何直接父接口继承的成员（Members inherited from any direct superinterfaces） 类中声明的成员（Members declared in the body of the class） 类中声明为私有的成员不会被该类的子类继承。（Members of a class that are declared private are not inherited by subclasses of that class.）\n只有声明为受保护（protected）或公共（public）的类成员才会被本包外的子类继承。（Only members of a class that are declared protected or public are inherited by subclasses declared in a package other than the one in which the class is declared.）\n构造器（constructors）、静态初始化器（static initializers）和实例初始化器（instance initializers）不是类成员，因此不会被继承。（Constructors, static initializers, and instance initializers are not members and therefore are not inherited.）\n超类的私有成员 了解完 Java 类成员后，再来看 Oracle 官方 Java 教程中关于超类的私有成员的说明：\n子类不继承父类的私有成员。不过，如果超类有访问其私有字段的公共或保护方法，子类也可以使用这些方法（间接访问父类的私有属性）。（A subclass does not inherit the private members of its parent class. However, if the superclass has public or protected methods for accessing its private fields, these can also be used by the subclass.）\n官方已明确说明子类不继承父类的私有成员，那为什么子类对象可以访问父类的私有成员呢？ 博主认为，继承是发生在类之间行为，而非对象之间的行为。子类 Child 不继承父类 Parent 的私有成员，并不代表子类对象 child 不可以拥有父类的属性。\n综上所述，子类不继承父类的私有成员，但子类对象包含父类的私有成员，并且可以通过父类提供的公有（public）或受保护（protected）方法来访问。\n参考资料 知乎：java中子类有没有继承父类的私有变量？ Java Language Specification : 8.2. Class Members Oracle Java Tutorial: Private Members in a Superclass Do subclasses inherit private fields? ","permalink":"http://localhost:1313/zh/posts/tech/0001-java-private-inheritance/","summary":"Java 中子类是否继承父类的私有属性？大家的疑惑无非是：如果子类不继承父类的私有属性，那子类对象为什么包含父类的私有属性？博主之前也同样疑惑，在查阅了相关资料后，得出如下结论：\n子类对象确实存在父类的私有属性，但子类不继承父类的私有属性。\n子类对象包含父类私有属性 首先，博主先验证子类对象包含父类的私有属性，代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 class Parent { private int privateField; public Parent() { System.out.println(\u0026#34;this in Parent() =\u0026gt; \u0026#34; + this); this.privateField = 666; } public Parent(int privateField) { System.out.println(\u0026#34;this in Parent(int) =\u0026gt; \u0026#34; + this); this.","title":"Java 中父类的私有属性可以被子类继承吗？"},{"content":"数组 链表 栈 队列 字符串 树 图 ","permalink":"http://localhost:1313/zh/posts/cs/0001-data-structures-and-algorithms/","summary":"数组 链表 栈 队列 字符串 树 图 ","title":"数据结构与算法"},{"content":"props 用于只读数据通信 组件通信——props Parent.vue Child.vue App.vue \u0026ltscript setup lang=\"ts\"\u003e import Parent from './components/Parent.vue'; \u0026lt/script\u003e \u0026lttemplate\u003e \u0026lth1\u003eApp Component \u0026ltParent /\u003e \u0026lt/template\u003e \u0026ltstyle scoped\u003e \u0026lt/style\u003e \u0026ltscript setup lang=\"ts\"\u003e const props = defineProps(['money']); \u0026lt/script\u003e \u0026lttemplate\u003e \u0026ltp\u003eChild Component: props from parent: {{ money }}\u0026lt/p\u003e \u0026lt/template\u003e \u0026ltstyle scoped\u003e \u0026lt/style\u003e \u0026ltscript setup lang=\"ts\"\u003e import Parent from './components/Parent.vue'; \u0026lt/script\u003e \u0026lttemplate\u003e \u0026lth1\u003eApp Component \u0026ltParent /\u003e \u0026lt/template\u003e \u0026ltstyle scoped\u003e \u0026lt/style\u003e 自定义事件（子父） 全局时间总线$bus（任意组件） v-model（） useAttrs 方法（） 发布订阅模式（任意组件） vuex（任意组件） ref 与 $parent（父子） provide 与 inject pinia 插槽 slot（父子） ","permalink":"http://localhost:1313/zh/posts/tech/0003-interactions-between-components-in-vue3/","summary":"props 用于只读数据通信 组件通信——props Parent.vue Child.vue App.vue \u0026ltscript setup lang=\"ts\"\u003e import Parent from './components/Parent.vue'; \u0026lt/script\u003e \u0026lttemplate\u003e \u0026lth1\u003eApp Component \u0026ltParent /\u003e \u0026lt/template\u003e \u0026ltstyle scoped\u003e \u0026lt/style\u003e \u0026ltscript setup lang=\"ts\"\u003e const props = defineProps(['money']); \u0026lt/script\u003e \u0026lttemplate\u003e \u0026ltp\u003eChild Component: props from parent: {{ money }}\u0026lt/p\u003e \u0026lt/template\u003e \u0026ltstyle scoped\u003e \u0026lt/style\u003e \u0026ltscript setup lang=\"ts\"\u003e import Parent from './components/Parent.vue'; \u0026lt/script\u003e \u0026lttemplate\u003e \u0026lth1\u003eApp Component \u0026ltParent /\u003e \u0026lt/template\u003e \u0026ltstyle scoped\u003e \u0026lt/style\u003e 自定义事件（子父） 全局时间总线$bus（任意组件） v-model（） useAttrs 方法（） 发布订阅模式（任意组件） vuex（任意组件） ref 与 $parent（父子） provide 与 inject pinia 插槽 slot（父子） ","title":"Vue3 组件通信"},{"content":"HTML CSS Javascript Ajax Promise Axios TypeScript Vue3 创建 Vue 项目 npm create vue@latest 根据需要构建项目 Vue.js - The Progressive JavaScript Framework ✔ Project name: … vue3_test ✔ Add TypeScript? … No / Yes ✔ Add JSX Support? … No / Yes ✔ Add Vue Router for Single Page Application development? … No / Yes ✔ Add Pinia for state management? … No / Yes ✔ Add Vitest for Unit Testing? … No / Yes ✔ Add an End-to-End Testing Solution? › Playwright ✔ Add ESLint for code quality? … No / Yes ✔ Add Prettier for code formatting? … No / Yes ✔ Add Vue DevTools 7 extension for debugging? (experimental) … No / Yes Scaffolding project in /Users/signalfish/vscode_workspace/vue/vue3_test... Done. Now run: cd vue3_test npm install npm run format npm run dev setup() setup() 函数是 Composition API 引入的新功能，用于替换 Vue2 中 Options API 的 data，methods，computed 选项。 setup() 函数返回的对象中的内容，可直接在模板中使用。 setup() 演示 \u0026lttemplate\u003e \u0026ltdiv\u003e \u0026ltp\u003eCount: {{ count }}\u0026lt/p\u003e \u0026ltbutton @click=\"increment\"\u003eIncrement\u0026lt/button\u003e \u0026lt/div\u003e \u0026lt/template\u003e \u0026ltscript\u003e import { ref } from 'vue'; export default { setup() { // Define reactive data const count = ref(0); // Define a method function increment() { count.value++; } // Expose data and methods to the template return { count, increment }; } } \u0026lt/script\u003e setup() 函数中的 this 是 undefined。因为 setup() 函数是在组件实例创建前运行。 setup() 函数的返回值可以是一个对象，也可以是一个函数。如果 setup() 返回一个对象，则该对象中的属性或方法可以直接在模版中使用。如果 setup() 返回一个函数，则该函数会被作为组件的渲染函数。例如： setup() 返回函数 setup() { return () =\u003e 'Hello, Vue 3!'; }; } setup() 与 Options API 的关系： Vue2 的选项（data、methods等）可以访问到 setup() 中的属性、方法，但在 setup() 中不能访问到 Vue2 的选项。 当被访问的属性或方法同时存在于 setup() 函数或 Vue2 的选项中，则优先访问 setup() 函数中的属性或方法。 setup() 语法糖： setup 语法糖 \u0026ltscript\u003e import { ref } from 'vue'; export default { setup() { // Define reactive data const count = ref(0); // Define a method function increment() { count.value++; } // Expose data and methods to the template return { count, increment }; } } \u0026lt/script\u003e \u0026ltscript setup\u003e import { ref } from 'vue'; // Define reactive data const count = ref(0); // Define a method function increment() { count.value++; } \u0026lt/script\u003e ref() 与 reactive() ref() 用于定义基本类型和对象类型的响应式数据，reactive() 用于定义对象类型的响应式数据。 创建基本类型的响应式数据，必须使用 ref()；创建层级较浅的响应式对象，使用 ref() 和 reactive() 均可以；创建层级较深的响应式对象，使用 reactive()。 在 JS/TS 中操作有 ref() 创建的响应式数据时，需要使用 .value。 在 JS/TS 中操作有 ref() 创建的响应式数据 \u0026ltscript setup lang=\"ts\"\u003e import { ref } from 'vue'; let age = ref(18); function changeAge() { // Accessing and modifying the age using .value age.value += 1; console.log(age.value); } \u0026lt/script\u003e 将一个对象赋值给由 reactive() 创建的变量时，该变量会失去响应性。为保持变量的响应性，可以使用 Object.assign() 方法整体替换该变量的所有属性。 使用 Object.assign() 保持对象响应性 \u0026ltscript setup lang=\"ts\"\u003e import { reactive } from 'vue'; const state = reactive({ count: 0, message: 'Hello' }); // 重新给 state 变量赋值一个新对象，将失去响应性 // state = { count: 1, message: 'New message' }; function changeState() { // 使用 Object.assign() 整体替换 state 的所有属性以保持响应性 Object.assign(state, { count: 1, message: 'New message' }); } \u0026lt/script\u003e toRef() 和 toRefs() computed() watch() watchEffect() 标签的 ref 属性 props 生命周期 Vue3 组件生命周期流程图 vue3-component-lifecycle with hooks 自定义 hook 路由 Pinia 组件通信 插槽 slot React 微信小程序 Java MySQL JDBC Java Web Maven Gradle Spring6 Spring MVC MyBatis MyBatis Plus SSM Redis SpringBoot2 SpringCloud Git Docker Elasticsearch ZooKeeper Nginx SpringSecurity ActiveMQ RabbitMQ RocketMQ K8S ","permalink":"http://localhost:1313/zh/posts/tech/-1-programming-handbook/","summary":"HTML CSS Javascript Ajax Promise Axios TypeScript Vue3 创建 Vue 项目 npm create vue@latest 根据需要构建项目 Vue.js - The Progressive JavaScript Framework ✔ Project name: … vue3_test ✔ Add TypeScript? … No / Yes ✔ Add JSX Support? … No / Yes ✔ Add Vue Router for Single Page Application development? … No / Yes ✔ Add Pinia for state management? … No / Yes ✔ Add Vitest for Unit Testing? … No / Yes ✔ Add an End-to-End Testing Solution?","title":"编程参考手册"},{"content":"请求与响应 【图】请求与响应示意图\n【HTTP协议】 请求格式 响应格式 内容类型 总结：The communication between the browser and server is controlled by the HTTP protocol. The two major parts of the protocol cover the request and response: the request from the browser and the response from the server must have specific formats. The server also indicates the type of the content that is being sent to the browser, so that the browser will know how to display it.\n在网页上传输数据 Form 总结：HTML forms are the way that browsers accept information from a user and send it to the server. The basic input tags were covered: text and submit. When the browser sends the data to the server, the data must be formatted so that it can be passed in a URL. It is placed in the query string.\nJSP servlet 总结：JSPs are one of the ways that dynamic content can be displayed in a web application. EL displays dynamic content from within a JSP. EL can be used to initialise form elements with data sent to the page.\nJSPs are an abstraction: they are translated into Java programs, known as servlets, by the servlet engine. The servlet engine is an application that is called by the web server to handle JSPs and servlets. The servlet engine encapsulates the request and response information from the server into objects and passes them to the servlets\nMVC int a = 1; int main() { return 0; } function fun() { let obj = { name, age } const a = 1; } // Function to calculate the factorial of a number recursively Function to calculate the factorial of a number recursively func factorial(n int) int { if n == 0 { return 1 } return n * factorial(n-1) } 点击展开：$f(x) = x^2 \u0026#43; 1$ $ f(x) = x^2 + 1; $ ","permalink":"http://localhost:1313/zh/posts/tech/0002-birds-eye-of-java-web/","summary":"请求与响应 【图】请求与响应示意图\n【HTTP协议】 请求格式 响应格式 内容类型 总结：The communication between the browser and server is controlled by the HTTP protocol. The two major parts of the protocol cover the request and response: the request from the browser and the response from the server must have specific formats. The server also indicates the type of the content that is being sent to the browser, so that the browser will know how to display it.","title":"鸟瞰 Java Web"}]